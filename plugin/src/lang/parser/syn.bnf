{
  generateTokens=true
  generatePsi=true
  generateStubParser=true

  parserClass="com.siberika.idea.pascal.lang.parser.PascalParser"
  stubParserClass="com.siberika.idea.pascal.lang.parser.PascalParserUtil"

  implements="com.siberika.idea.pascal.lang.psi.PascalPsiElement"
  extends="com.siberika.idea.pascal.lang.psi.impl.PascalPsiElementImpl"

  psiClassPrefix="Pas"
  psiImplClassSuffix="Impl"
  psiPackage="com.siberika.idea.pascal.lang.psi"
  psiImplPackage="com.siberika.idea.pascal.lang.psi.impl"
  psiImplUtilClass="com.siberika.idea.pascal.lang.psi.impl.PascalPsiImplUtil"

  elementTypeHolderClass="com.siberika.idea.pascal.lang.psi.PasTypes"
  elementTypePrefix=""
  elementTypeClass="com.siberika.idea.pascal.lang.psi.PascalPsiElementType"
  tokenTypeClass="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  tokens = [
        COMMENT='regexp:\(\*\w*\*\)'
        STRING_LITERAL="STRING_LITERAL"

        AND="and"
        MOD="mod"
        OR="or"
        IDIV="div"
        SHR="shr"
        SHL="shl"
        IN="in"

        AS="as"
        IS="is"
        NIL="nil"

        CLASS="class"
        DISPINTERFACE="dispinterface"

        TRY="try"
        RAISE="raise"
        EXCEPT="except"
        ON="on"
        FINALLY="finally"

        PROGRAM="program"
        UNIT="unit"
        LIBRARY="library"
        PACKAGE="package"
        USES="uses"
        EXPORTS="exports"
        FINALIZATION="finalization"
        INITIALIZATION="initialization"

        THREADVAR="threadvar"
        ABSOLUTE="absolute"
        OUT="out"
        RESOURCESTRING="resourcestring"
        INLINE="inline"
        PACKED="packed"
        PROPERTY="property"
        ARRAY="array"
        SET="set"
        FILE="file"

        ASM="asm"
        GOTO="goto"
        LABEL="label"
        WITH="with"
        EXIT="exit"
        CONTINUE="continue"
        BREAK="break"

        CONSTRUCTOR="constructor"
        DESTRUCTOR="destructor"
        INHERITED="inherited"
        OBJECT="object"
        OPERATOR="operator"
        REINTRODUCE="reintroduce"
        SELF="self"

        NOT="not"
        XOR="xor"

        TO="to"
        DOWNTO="downto"
        REPEAT="repeat"

        STATIC="static"
        SEALED="sealed"
        FINAL="final"
        HELPER="helper"
        EXPORT="export"
        DISPID="dispid"
        ABSTRACT="abstract"

        STRICT="strict"
        PUBLISHED="published"
        PUBLIC="public"
        PROTECTED="protected"
        PRIVATE="private"
        AUTOMATED="automated"

        MESSAGE="message"
        FORWARD="forward"
        EXTERNAL="external"
        EXPERIMENTAL="experimental"
        DEPRECATED="deprecated"
        ASSEMBLER="assembler"

        INDEX="index"
        DEFAULT="default"

        VIRTUAL="virtual"
        DYNAMIC="dynamic"
        OVERRIDE="override"
        OVERLOAD="overload"

        REGISTER="register"
        STDCALL="stdcall"
        PLATFORM="platform"
        PASCAL="pascal"
        CDECL="cdecl"
        SAFECALL="safecall"

        REFERENCE="reference"

        IMPLEMENTS="implements"
        REQUIRES="requires"
        CONTAINS="contains"

        POINTER="pointer"
        FALSE="false"
        TRUE="true"

        INTERFACE="interface"
        IMPLEMENTATION="implementation"

        VAR="var"
        CONST="const"
        TYPE="type"
        ARRAY="array"
        RECORD="record"
        PROCEDURE="procedure"
        FUNCTION="function"
        OF="of"

        CASE="case"
        BEGIN="begin"
        END="end"
        FOR="for"
        UNTIL="until"
        WHILE="while"
        DO="do"
        IF="if"
        THEN="then"
        ELSE="else"

        READ="read"
        WRITE="write"

        MULT="*"
        PLUS="+"
        MINUS="-"
        DIV="/"
        SEMI=";"
        COMMA=","
        LPAREN="("
        RPAREN=")"
        LBRACK="["
        RBRACK="]"
        EQ="="
        LT="<"
        GT=">"
        GE=">="
        LE="<="
        NE="<>"
        COLON=":"
        ASSIGN=":="
        DOT="."
        DEREF="^"
        AT="@"
        HEXNUM="$"
        CHARNUM="#"
        KEYWORDESCAPE="&"

        INCLUDE="include"
        CT_DEFINE="ct_define"
        CT_UNDEFINE="ct_undefine"
        CT_IFDEF="ct_ifdef"
        CT_IFNDEF="ct_ifndef"
        CT_ELSE="ct_else"
        CT_ENDIF="ct_endif"
        COMP_OPTION="comp_option"

        NAME='regexp:[_\w]\w*'
        RANGE='..'
  ]

  implements(".*QualifiedIdent|NamespaceIdent")="com.siberika.idea.pascal.lang.psi.PascalQualifiedIdent"
  implements(".*ModuleHead|.*Ident|ClassProperty|FormalParameter")="com.siberika.idea.pascal.lang.psi.PascalNamedElement"
  extends(".*ModuleHead|.*Ident|ClassProperty|FormalParameter")="com.siberika.idea.pascal.lang.psi.impl.PascalNamedElementImpl"
  extends("ClassTypeDecl|ObjectDecl|ClassHelperDecl|InterfaceTypeDecl|RecordDecl|RecordHelperDecl")="com.siberika.idea.pascal.lang.psi.impl.PasEntityScopeImpl";
}

//external pascal             ::= parsePascal Module
Module                      ::= ModuleUnit | ModuleProgram | ModuleLibrary | ModulePackage
                            {recoverWhile=recover_main_decl extends="com.siberika.idea.pascal.lang.psi.impl.PascalModuleImpl"
                             implements="com.siberika.idea.pascal.lang.psi.PasEntityScope"}

ModuleProgram               ::= progWithHead | progWoHead
private progWithHead        ::= ProgramModuleHead progWoHead
private progWoHead          ::= [UsesFileClause] BlockGlobal "."

private ModuleUnit          ::= UnitModuleHead UnitInterface UnitImplementation "."
UnitModuleHead              ::= UNIT NamespaceIdent HintingDirective* ";" {pin=1}
UsesClause                  ::= USES NamespaceNameList {pin=1}

private ModuleLibrary       ::= LibraryModuleHead [UsesFileClause] BlockGlobal "." {pin=1}
LibraryModuleHead           ::= LIBRARY NamespaceIdent HintingDirective* ";" {pin=1 recoverWhile=recover_main_decl}

private ModulePackage       ::= PackageModuleHead RequiresClause [ContainsClause] END "." {pin=1}
PackageModuleHead           ::= PACKAGE NamespaceIdent ";" {pin=1 recoverWhile=recover_main_decl}
RequiresClause              ::= REQUIRES NamespaceNameList {pin=1}
ContainsClause              ::= CONTAINS NamespaceFileNameList {pin=1}

UnitInterface               ::= INTERFACE [UsesClause] InterfaceDecl* {pin=1 recoverWhile=rec_interface name="interface section"}
//private rec_interface       ::= !(IMPLEMENTATION)

private InterfaceDecl       ::= commonDecl | RoutineDecl | ExportsSection | AssemblyAttribute {recoverWhile=recover_decl}
private AssemblyAttribute   ::= "[" "assembly" ":" CustomAttributeDecl "]" {pin=2}
private ExportsSection      ::= EXPORTS Identifier ExportItem ("," Identifier ExportItem)* ";" {pin=1}
private ExportItem          ::= ["(" [FormalParameterList] ")"] [INDEX Expression] ["name" Expression] ["resident"]
ExportedRoutine             ::= ExportedProc | ExportedFunc {extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl"}
private ExportedFunc        ::= FUNCTION NamedIdent [FormalParameterSection] ":" [CustomAttribute] TypeDecl ";" FunctionDirective* {pin=1 recoverWhile=recover_decl}
private ExportedProc        ::= PROCEDURE NamedIdent [FormalParameterSection] ";" FunctionDirective* {pin=1 recoverWhile=recover_decl}

private StrucType           ::= [PACKED] StrucTypePart
private StrucTypePart       ::= ClassDecl | ArrayType | SetType | FileType
private ClassDecl           ::= ClassTypeTypeDecl | ClassHelperDecl | ClassTypeDecl | InterfaceTypeDecl | ObjectDecl | RecordHelperDecl | RecordDecl

private RoutineDecl         ::= ExportedRoutine | ClassMethodResolution | ClassMethod
private commonDecl          ::= ClassProperty | ConstSection | TypeSection | [CLASS] VarSection
private StructItem          ::= commonDecl | RoutineDecl | ClassField | Visibility {recoverWhile=recover_classItem} // TODO: remove routines



UnitImplementation          ::= IMPLEMENTATION [UsesClause] ImplDeclSection UnitBlock {pin=1 recoverWhile=recover_impl name="implementation section"}
ImplDeclSection             ::= (MethodImplDecl | RoutineImplDecl | DeclSection)* {recoverWhile=recover_impl}
private UnitBlock           ::= UnitInitialization [UnitFinalization] END | CompoundStatement | END {recoverWhile=recover_impl}
UnitInitialization          ::= INITIALIZATION StatementList {pin=1 name="initialization section"}
UnitFinalization            ::= FINALIZATION StatementList  {pin=1 name="finalization section"}

ProgramModuleHead	        ::= PROGRAM NamespaceIdent ProgramParamList? ";" {pin=1 recoverWhile=recover_decl}
ProgramParamList            ::= LPAREN progParam? progParamsRest* RPAREN {pin=1}
private progParamsRest      ::= "," progParam {pin=1}
private progParam           ::= Identifier {recoverWhile=recover_progParams}
private recover_progParams  ::= !(',' | ')' | global_decl)

UsesFileClause	            ::=	USES NamespaceFileNameList {pin=1 name="uses clause"}
private NamespaceFileNameList ::= NamespaceFileName NamespaceFileNamesRest* ";"
private NamespaceFileNamesRest ::= COMMA NamespaceFileName {pin=1}
private NamespaceFileName	::=	NamespaceIdent [IN QuotedString] {recoverWhile=recover_uses_list}
private recover_uses_list   ::= !(',' | global_decl)
private recover_commaList   ::= !(";" | ')' | ',' | ':' | '.' | "]" | DO)

private NamespaceNameList   ::= NamespaceIdent NamespaceNamesRest* ";"
private NamespaceNamesRest  ::= "," NamespaceIdent {pin=1 recoverWhile=recover_uses_list}

private recover_main_decl   ::= !(main_decl)
private recover_decl        ::= !(global_decl | END)

private recover_impl        ::= !(local_decl | END | FINALIZATION | INITIALIZATION)

private local_decl          ::= ';' | '.' | BEGIN | VarKey | ProcKey | ConstKey | PROPERTY | TYPE | LABEL
private global_decl         ::= local_decl | CONSTRUCTOR | DESTRUCTOR | FINALIZATION | INITIALIZATION
                              | CLASS | EXPORTS | INTERFACE | IMPLEMENTATION | USES | CONTAINS | REQUIRES
private main_decl           ::= local_decl | global_decl | PROGRAM | UNIT | LIBRARY | PACKAGE

private decl_list           ::= ',' | ';' | BEGIN
private recover_var         ::= !(decl_list | Identifier | global_decl)
//private recover_const       ::= !(decl_list | Ident)
private recover_type        ::= !(global_decl | Identifier '=' | TYPE)

//';' | '.' | BEGIN | VarKey | ProcKey | ConstKey | TYPE | LABEL
//private global_decl        ::= local_decl | FINALIZATION | INITIALIZATION | CLASS | EXPORTS | INTERFACE | IMPLEMENTATION | USES | CONTAINS | REQUIRES

BlockGlobal	                ::=	[';'] DeclSection* BlockBody {pin=2 recoverWhile=recover_declName}
BlockBody	        ::=	CompoundStatement |	AssemblerStatement

AssemblerStatement  ::= ASM AssemblerItem* END
private AssemblerItem       ::= ',' | '[' | ']' | ':' | '+' | '-' | '*' | '/' | '@' | Identifier | NUMBER_INT | NUMBER_HEX | NUMBER_BIN

DeclSection	        ::=	commonDecl | LabelDeclSection | ExportsSection | AssemblyAttribute {recoverWhile=recover_decl}

//private recover_declEnd     ::= BEGIN | TYPE | VarKey | ConstKey | ProcKey | Ident '=' | END
//                              | INITIALIZATION | INTERFACE | IMPLEMENTATION | LABEL

private ProcKey             ::= FUNCTION | PROCEDURE
RoutineImplDecl             ::= RoutineDeclHeading ";" FunctionDirective* ProcBodyBlock
                                {pin=1 recoverWhile=recover_decl name="procedure or function declaration"
                                 extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl" implements="com.siberika.idea.pascal.lang.psi.PascalNamedElement"}
MethodImplDecl              ::= MethodDeclHeading ";" MethodDirective* [MethodBody]
                                {extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl" implements="com.siberika.idea.pascal.lang.psi.PascalNamedElement"}

private RoutineDeclHeading  ::= funcDecl | procDecl
private MethodDeclHeading   ::= FuncMethod | ProcMethod

private funcDecl            ::= [CustomAttribute] FUNCTION  NamedIdent [FormalParameterSection] ":" TypeDecl {pin=2 recoverWhile=recover_decl}
private procDecl            ::= [CustomAttribute] PROCEDURE NamedIdent [FormalParameterSection] {pin=2 recoverWhile=recover_decl}
private ProcMethod          ::= [CustomAttribute] MethodKey ClassQualifiedIdent [GenericDefinition] [FormalParameterSection] {recoverWhile=recover_decl}
private FuncMethod          ::= [CustomAttribute] [CLASS] FUNCTION ClassQualifiedIdent [GenericDefinition] [FormalParameterSection] ":" [CustomAttribute] TypeDecl {recoverWhile=recover_decl}

private FunctionDirective   ::= OverloadDirective | InlineDirectiveSemi | CallConventionSemi | OldCallConventionDirectiveSemi | HintingDirective ";" | ExternalDirective // | "unsafe" ";"
private OverloadDirective   ::= OVERLOAD ";"
private OldCallConventionDirectiveSemi ::= OldCallConventionDirective ";"
private OldCallConventionDirective ::= "far" | "local" | "near"
private ExternalDirective   ::= "varargs" ";" | EXTERNAL ";" | EXTERNAL ConstExpression ExternalSpecifier* ";"
private ExternalSpecifier   ::= "name" ConstExpression | INDEX ConstExpression
ProcBodyBlock               ::= ProcForwardDecl | ProcExternalDecl | BlockGlobal [";"]
private ProcExternalDecl    ::= EXTERNAL ("name" Expression | INDEX Expression)* FunctionDirective* {pin=1}
ProcForwardDecl             ::= FORWARD ";" FunctionDirective* {pin=1}

MethodBody          ::= BlockGlobal ";"
MethodKey           ::= [CLASS] PROCEDURE | CONSTRUCTOR | DESTRUCTOR | CLASS OPERATOR
MethodDirective     ::= REINTRODUCE ';' | OVERLOAD ';' | BindingDirective | AbstractDirectiveSemi | InlineDirectiveSemi
                      | CallConventionSemi | HintingDirective ";" | DispIDDirective {recoverWhile=recover_classItem}
private DispIDDirective     ::= DISPID Expression ";" {pin=1}
private CallConventionSemi  ::= CallConvention ";"
private CallConvention      ::= CDECL | PASCAL | REGISTER | SAFECALL | STDCALL | EXPORT
private InlineDirectiveSemi ::= InlineDirective ";"
private InlineDirective     ::= INLINE | ASSEMBLER
private AbstractDirectiveSemi ::= AbstractDirective ";"
private AbstractDirective   ::= ABSTRACT | FINAL
private BindingDirective    ::= ((MESSAGE Expression) | STATIC | DYNAMIC | OVERRIDE | VIRTUAL) ";"

LabelDeclSection	        ::=	LABEL Label LabelsRest* ";" {pin=1 name="label declaration"}
private LabelsRest          ::= "," Label {recoverWhile=recover_commaList}
private Label               ::= Identifier | NUMBER_INT | NUMBER_HEX

VarSection	                ::=	VarKey VarDeclaration+ {pin=1 name="var section"}
private VarKey	            ::=	VAR | THREADVAR
private VarDeclaration	    ::=	[CustomAttribute] IdentList ":" TypeDecl [VarValueSpec] HintingDirective* ";" {pin=3 recoverWhile=recover_var}
VarValueSpec	            ::=	ABSOLUTE Identifier | ABSOLUTE ConstExpressionOrd | EQ ConstExpression

ConstSection                ::= ConstKey ConstDeclaration+ {pin=1 name="const section"}
private ConstKey            ::= CONST |	RESOURCESTRING
private ConstDeclaration    ::= [CustomAttribute] NamedIdent [":" TypeDecl] "=" ConstExpression HintingDirective* ";" {pin=2}
NamedIdent                  ::= Identifier

TypeSection                 ::= TYPE TypeDeclaration+ {pin=1 name="type section"}
TypeDeclaration             ::= [CustomAttribute] GenericTypeIdent "=" TypeDecl HintingDirective* ";" {pin=3 recoverWhile=recover_type}
GenericTypeIdent    ::= Identifier [GenericDefinition]
GenericDefinition   ::= SimpleGenericDefinition | ConstrainedGenericDefinition
SimpleGenericDefinition ::= "<" Identifier IdentsRest* ">" {pin=1}
IdentsRest          ::= "," Identifier {pin=1}
ConstrainedGenericDefinition ::= "<" ConstrainedGeneric ConstrainedGenericsRest ">" {pin=1}
ConstrainedGeneric  ::= Identifier [ ":" GenericConstraint GenericConstraintsRest ]
GenericConstraint   ::= Identifier | RECORD | CLASS | CONSTRUCTOR
GenericConstraintsRest ::= "," GenericConstraint {pin=1}
ConstrainedGenericsRest ::= ";" ConstrainedGeneric {pin=1}
GenericPostfix      ::=	"<" TypeDecl TypeDeclsRest* ">" {pin=1}
TypeDeclsRest       ::= "," TypeDecl {pin=1}

private recover_declName        ::= !('(' | ')' | ',' | '.' | ':' | ';' | '[' | ']' | '^' | ':=' | 'add' | 'at'
                                | ABSOLUTE | ASSEMBLER | AUTOMATED | BEGIN | CASE | CDECL | CLASS | CONST | CONSTRUCTOR
                                | DEPRECATED | DESTRUCTOR | DO | DEFAULT | DISPID | DOWNTO | ELSE | END | EXCEPT | EXPERIMENTAL
                                | EXPORT | EXTERNAL | FINALLY | FUNCTION | INDEX | INHERITED | INITIALIZATION | FINALIZATION
                                | INLINE | INTERFACE | IMPLEMENTATION | KEYWORDESCAPE | LABEL | LBRACK | MINUS | NAME
                                | IN | IMPLEMENTS | NOT | NUMBER_HEX | NUMBER_INT | OF | OVERLOAD | PASCAL | PLATFORM | PLUS | PROCEDURE | REGISTER
                                | RESOURCESTRING | RPAREN | SAFECALL | STDCALL | THEN | THREADVAR | TO | TYPE | UNTIL | VAR
                                | PRIVATE | PROPERTY | PROTECTED | PUBLIC | PUBLISHED | RANGE | READ | STRICT | WRITE | USES
                                | CONTAINS | REQUIRES | (Identifier "=") | RelOp | AddOp | MulOp
                                | 'far' | 'local' | 'name' | 'near' | 'nodefault' | 'readonly' | 'remove' | 'stored' | 'varargs' | 'writeonly')

TypeID              ::=	FullyQualifiedIdent

TypeDecl	                ::=	StrucType | PointerType | ProcedureType | StringType | VariantType | SimpleType | [TYPE] TypeID [GenericPostfix]

ClassField          ::= [CustomAttribute] IdentList ":" TypeDecl HintingDirective* ';' {pin=3}

ClassTypeDecl               ::= CLASS (ClassBody | [ClassParent]) {pin=1 name="class declaration"}
private ClassBody           ::= [ClassState] [ClassParent] StructItem* END
ClassHelperDecl             ::= CLASS HELPER [ClassParent] FOR TypeID ClassHelperItem* END {pin=2}
private ClassHelperItem     ::= Visibility | ClassMethod | ClassProperty | [CLASS] VarSection {recoverWhile=recover_classItem}
InterfaceTypeDecl           ::= InterfaceKey [ClassParent] [InterfaceGuid] InterfaceItem* END
                              | InterfaceKey [ClassParent] {pin(".*")=InterfaceKey}
private InterfaceItem       ::= ClassMethod | [CLASS] ClassProperty




ClassTypeTypeDecl           ::= CLASS OF TypeID {pin(".*")="class of" name="metaclass declaration"}

ClassState          ::= SEALED | ABSTRACT

private recover_classItem   ::= !('[' | Identifier
                                | CLASS | CONST | CONSTRUCTOR | DESTRUCTOR | BEGIN | END | FUNCTION | IMPLEMENTS | KEYWORDESCAPE
                                | OPERATOR | PRIVATE | PROCEDURE | PROPERTY | PROTECTED | PUBLIC | PUBLISHED | RESOURCESTRING
                                | STATIC | STRICT | THREADVAR | TYPE | VAR | VIRTUAL)

ClassMethodResolution ::= [CLASS] ProcKey GenericTypeIdent "." Identifier "=" Identifier ";"
ClassParent         ::= "(" TypeID ("," TypeID)* ")" {pin=1}

private InterfaceGuid       ::= "[" QuotedString "]" {pin=1}
private InterfaceKey        ::= INTERFACE | DISPINTERFACE

ObjectDecl                  ::= OBJECT [ClassParent] ObjectItem* END
                                {pin=1 name="object declaration"}
private ObjectItem          ::= Visibility | ClassMethod | ClassField {recoverWhile=recover_classItem}

Visibility                  ::= [STRICT] PRIVATE | [STRICT] PROTECTED | PUBLIC | PUBLISHED | AUTOMATED

RecordDecl          ::= RECORD (VariantRecord | SimpleRecord) END
                        {pin=1 name="record declaration"}
private SimpleRecord        ::= RecordFieldSemi* RecordItem*
private VariantRecord       ::= RecordFieldSemi* RecordVariantSection
private RecordItem          ::= Visibility | ClassMethod | ClassProperty | ConstSection | TypeSection | RecordField | [CLASS] VarSection {recoverWhile=recover_classItem}
RecordField         ::= IdentList ":" TypeDecl HintingDirective* {pin=2 recoverWhile=recover_declName}
private RecordFieldSemi     ::= RecordField ';'
RecordFields        ::= [RecordField] (';' RecordField)* [';']  //===***
private RecordVariantSection ::= CASE [Identifier ":"] TypeDecl OF (RecordVariant | ";" )+ {pin=1}
private RecordVariant       ::= ConstExpression ("," ConstExpression)* ":" "(" RecordFields ")" {pin=3}

RecordHelperDecl            ::= RECORD HELPER FOR TypeID RecordHelperItem* END {pin=2}
RecordHelperItem ::= Visibility | ClassMethod | ClassProperty {recoverWhile=recover_classItem}

ClassMethod         ::= classMethodProc | classMethodFunc {name="method declaration" extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl"}
private classMethodProc ::= MethodKey NamedIdent [GenericDefinition] [FormalParameterSection] ";" MethodDirective* {pin=1}
private classMethodFunc ::= [CLASS] FUNCTION NamedIdent [GenericDefinition] [FormalParameterSection] ":" [CustomAttribute] TypeDecl ";" MethodDirective* {pin=2}
ClassProperty ::= [CustomAttribute] [CLASS] PROPERTY NamedIdent [ClassPropertyArray] [":" TypeID] [ClassPropertyIndex] ClassPropertySpecifier* ";" {pin=3}
ClassPropertyArray ::= "[" FormalParameterList "]" {pin=1}
ClassPropertyIndex ::= INDEX ConstExpressionOrd {pin=1}
ClassPropertySpecifier ::= ClassPropertyReadWrite | ClassPropertyDispInterface | "stored" Expression
                                 | DEFAULT Expression | ';' DEFAULT | "nodefault" | IMPLEMENTS TypeID
ClassPropertyReadWrite ::= READ RefNamedIdent | WRITE RefNamedIdent | "add" RefNamedIdent | "remove" RefNamedIdent
RefNamedIdent       ::= Identifier
ClassPropertyDispInterface ::= "readonly" ";" | "writeonly" ";" | DispIDDirective

ArrayType           ::= ARRAY [ArrayIndexes] OF ArraySubType {pin=1}
ArrayIndexes ::= "[" [ArrayIndex] ArrayIndexRest* "]" {pin=1}
ArrayIndex          ::= ConstExpressionOrd RANGE ConstExpressionOrd | TypeID     //TODO: TypeID only?
ArrayIndexRest      ::= "," [ArrayIndex] {pin=1}
ArraySubType        ::= CONST | TypeDecl

SetType             ::= SET OF TypeDecl {pin=1}
FileType            ::= FILE [OF TypeDecl] {pin=1}
PointerType         ::= "^" TypeDecl | POINTER {pin=1}

private StringType          ::= "string" ["[" Expression "]"] | TypeID [CodePageNumber]
private CodePageNumber      ::= "(" ConstExpressionOrd ")" {pin=1}
private VariantType         ::= Identifier

ProcedureType       ::= MethodType | SimpleProcedureType | ProcedureReference
SimpleProcedureType ::= ProcedureTypeHeading
MethodType          ::= ProcedureTypeHeading OF OBJECT {pin=3}
ProcedureReference  ::= REFERENCE TO ProcedureTypeHeading {pin=1}
ProcedureTypeHeading ::= funcHeading | procHeading;
funcHeading         ::= FUNCTION [FormalParameterSection] ":" [CustomAttribute] TypeDecl {pin=1}
procHeading         ::= PROCEDURE [FormalParameterSection] {pin=1}

SimpleType          ::= Identifier | EnumType | SubRangeType
SubRangeType        ::= ConstExpressionOrd [RANGE ConstExpressionOrd]
EnumType            ::= "(" EnumEl EnumRest* ")" {pin=1}
EnumRest            ::= "," EnumEl {pin=1}
EnumEl              ::= Identifier ["=" Expression] {recoverWhile=recover_commaList}

CompoundStatement           ::= BEGIN [StatementList] END {pin=1}
StatementList               ::= [Statement] Statements* {recoverWhile=recover_block}
private Statements          ::= ";" [Statement] {recoverWhile=recover_statement}
private Statement           ::= [LabelId ":" ] StatementPart
private StatementPart       ::= RepeatStatement | WhileStatement | ForStatement
                              | CaseStatement | WithStatement | RaiseStatement | AssemblerStatement
                              | CompoundStatement | IfStatement | TryStatement | SimpleStatement | stmtEmpty
private recover_block ::= !(block_end | block_start)

private SimpleStatement     ::= GotoStatement | StmtSimpleOrAssign
StmtSimpleOrAssign          ::= Designator [assignPart]
assignPart                  ::= ":=" (NewStatement | Expression) {pin=1 recoverWhile=recover_statement}
NewStatement                ::= NEW "(" [ Expression ] ("," [ Expression ])* [ "," ConstExpression ] ")"// {pin=1 recoverWhile=recover_statement}
stmtEmpty           ::= //empty

private recover_statement   ::= !(';' | block_end | stmt_start | stmt_middle | block_start | VarKey | ConstKey | TYPE | ProcKey)

private stmt_start          ::= REPEAT | WHILE | FOR | CASE | WITH | RAISE | IF | TRY | BEGIN | BREAK | CONTINUE | EXIT | GOTO | INHERITED
                              | NUMBER_INT | NUMBER_HEX | NUMBER_REAL | Identifier | Ident_kw | KEYWORDESCAPE | '^' | '.' | '[' | '('
private stmt_middle         ::= DO | ELSE | THEN
private block_start         ::= BEGIN | INITIALIZATION | FINALIZATION
private block_end           ::= END | UNTIL | EXCEPT | FINALLY
private after_expr          ::= TO | DO | THEN | OF | DOWNTO | EXCEPT | INDEX | ELSE
                              | "name" | OVERLOAD | InlineDirective | CallConvention | OldCallConventionDirective
                              | DEPRECATED | EXPERIMENTAL | PLATFORM | LIBRARY | "varargs" | EXTERNAL | "unsafe"
                              | REINTRODUCE | BindingDirective | AbstractDirective | ClassPropertySpecifier

Designator                  ::= //[ "inherited" ] , [ QualifiedIdent | TypeID ] , { DesignatorItem } ===***
                                INHERITED [TypeID] DesignatorItem2? | EntityID DesignatorItemEx* | DesignatorItemEx+

EntityID                    ::= FullyQualifiedIdent
FieldId                     ::= Identifier

DesignatorItem      ::= "^" | "." FieldId | "[" ExpressionsList "]"
DesignatorItemEx    ::= DesignatorItem | DesignatorItem2
DesignatorItem2     ::= "(" [ExpressionColon ExpressionColons*] ")"// {pin=1}
ExpressionColon     ::= Expression [ColonConstruct] {recoverWhile=recover_commaList}
ExpressionColons    ::= "," ExpressionColon
ColonConstruct      ::= ":" Expression [ ":" Expression ]

RepeatStatement     ::= REPEAT [StatementList] UNTIL Expression {pin=1}
WhileStatement      ::= WHILE Expression DO Statement {pin=1}
ForStatement        ::= FOR Designator (ForCycle | IN) Expression DO Statement {pin=1}
ForCycle    ::= ":=" Expression (TO | DOWNTO)

IfStatement                 ::= IF Expression THEN Statement [ELSE Statement] {pin=1}

CaseStatement       ::= CASE Expression OF CaseItem* [ELSE StatementList [";"] ] END {pin=1}
CaseItem	        ::=	CaseLabel ("," CaseLabel)* ":" Statement [";"] {pin=3}
CaseLabel	        ::=	ConstExpressionOrd [RANGE ConstExpressionOrd] //{recoverWhile=recover_commaList}

TryStatement                ::= TRY StatementList (TryExcept | TryFinally) END {pin=1}
private TryFinally          ::= FINALLY StatementList
private TryExcept           ::= EXCEPT HandlerList
HandlerList                 ::= Handler+ [ELSE StatementList] | StatementList
Handler                     ::= ON Identifier ":" TypeID "do" Statement ";" {pin=1}

WithStatement               ::= WITH Designator DesignatorsRest* DO Statement {pin=1}
private DesignatorsRest     ::= "," Designator {recoverWhile=recover_commaList}

RaiseStatement              ::= RAISE [Designator] ["at" Designator] {pin=1}

GotoStatement               ::= GOTO LabelId | EXIT [ "(" Expression ")" ] | BREAK | CONTINUE

LabelId                     ::= Identifier | NUMBER_INT

SetSection                  ::=	"[" [ExpressionOrd SetRest*] "]"// {pin=1}
SetRest             ::= ("," | RANGE | ) ExpressionOrd //{recoverWhile=recover_commaList}

ClassQualifiedIdent         ::= SubIdent "." SubIdent
FullyQualifiedIdent	        ::=	NamespacePart? SubIdent
NamespaceIdent	            ::=	NamespacePart? SubIdent
SubIdent                    ::= Identifier
private NamespacePart       ::= NamespaceItem+
private NamespaceItem       ::= SubIdent "."// {pin=2 recoverWhile=recover_declName}

HintingDirective            ::= (DEPRECATED [StringFactor]) | EXPERIMENTAL | PLATFORM | LIBRARY// {recoverWhile=recover_hintingDir}
//recover_hintingDir          ::= !(';' | ')' | END | global_decl)

Ident_kw                    ::= OUT | EXIT | BREAK | CONTINUE | OPERATOR | SELF | NEW | REINTRODUCE | OVERLOAD | MESSAGE |STATIC | DYNAMIC
                              | OVERRIDE | VIRTUAL | ABSTRACT | SEALED | FINAL | ASSEMBLER | CDECL | PASCAL | REGISTER | SAFECALL | STDCALL
                              | EXPORT | STRICT | PRIVATE | PROTECTED | PUBLIC | PUBLISHED | AUTOMATED | DISPID | EXTERNAL | FORWARD | HELPER
                              | DEFAULT | IMPLEMENTS | INDEX | READ | WRITE | DEPRECATED | EXPERIMENTAL | PLATFORM | REFERENCE
                              | PACKAGE | CONTAINS | REQUIRES
private Identifier          ::= KEYWORDESCAPE ReservedWord | Ident_kw | NAME
ReservedWord	            ::=	NAME //===***
private IdentList	        ::=	IdentListItem IdentListRest*
private IdentListRest       ::= "," IdentListItem {pin=1}
private IdentListItem       ::= NamedIdent {recoverWhile=recover_declName}
//private recover_identList ::= !(')' | ',' | ':' | ';' | '=' | ']')

ConstExpressionOrd          ::=	ExpressionOrd {name="integer constant expression"}
ConstExpression	            ::=	Expression | NewConstExpression | RecordConstExpression {name="constant expression"}
NewConstExpression	        ::=	LPAREN ConstExpression (COMMA ConstExpression)* RPAREN | Expression
RecordConstExpression       ::= Expression | RecordConstValue;
RecordConstValue            ::= "(" RecordValue RecordValueRest* ")" {pin=1}
private RecordValueRest     ::= ";" RecordValue
private RecordValue         ::= Identifier ":" RecordConstExpression

private primary             ::= AT primary | AT AT primary | NOT primary | PLUS primary | MINUS primary
                              | NUMBER_INT | NUMBER_REAL | NUMBER_HEX | NUMBER_BIN | TRUE | FALSE | NIL
                              | "(" Expression ")" | StringFactor | SetSection | Designator

primaryOrd                  ::= NOT primaryOrd | PLUS primaryOrd | MINUS primaryOrd | NUMBER_INT | NUMBER_HEX | TRUE | FALSE | NIL
                              | "(" ExpressionOrd ")" | StringFactor | Designator

private RelOp               ::= "<" | ">" | "<=" | ">=" | "<>" | "=" | IN | IS
private AddOp               ::=	"+" | "-" | OR | XOR
private MulOp               ::= "*" | "/" | IDIV | MOD | AND | SHL | SHR | AS

Expression ::= ClosureExpression | expr_rel
private expr_rel            ::= expr_sum RelOpRest*
private RelOpRest           ::= RelOp expr_sum {pin=1 recoverWhile=recover_expression}
private expr_sum            ::= expr_product AddOpRest*
private AddOpRest           ::= AddOp expr_product {pin=1 recoverWhile=recover_expression}
private expr_product        ::= primary MulOpRest*
private MulOpRest           ::= MulOp primary {pin=1 recoverWhile=recover_expression}

ExpressionOrd ::= expr_relOrd
private expr_relOrd ::= expr_sumOrd (RelOp expr_sumOrd)*
private expr_sumOrd ::= expr_productOrd (AddOp expr_productOrd)*
private expr_productOrd ::= primaryOrd (MulOp primaryOrd)*

private recover_expression ::= !(';' | RelOp | MulOp | AddOp | END | ')' | ',' | ']' | ':' | after_expr)

/*expression ::= factor add_expression * {recoverWhile="expression_recover"}
private factor ::= primary mul_expression *
private primary ::= literal_expression | reference_expression qreference_expression *

left add_expression ::= '+' factor
left mul_expression ::= '*' primary

identifier ::= id
reference_expression ::= identifier {mixin="mypackage.MyReferenceExpressionImpl"}
left qreference_expression ::= '.' identifier {elementType="reference_expression"}

literal_expression ::= number | string*/

ClosureExpression           ::= PROCEDURE [ FormalParameterSection ] BlockGlobal | FUNCTION [ FormalParameterSection ] ":" TypeDecl BlockGlobal
FormalParameterSection      ::= "(" [ FormalParameterList ] ")"
FormalParameterList         ::= FormalParameter (";" FormalParameter)*
FormalParameter             ::= [ CustomAttribute ] [ ParamType ] IdentList [ ":" TypeDecl ] [ "=" Expression ]
ParamType                    ::= CONST | VAR | OUT | CONSTREF//ParmType


ExpressionsList	            ::= Expression (COMMA Expression)*

CustomAttribute	            ::=	LBRACK CustomAttributeDecl RBRACK | AssemblyAttribute
CustomAttributeDecl         ::= FullyQualifiedIdent LPAREN ExpressionsList RPAREN
StringFactor                ::= ControlString (QuotedString ControlString)* [QuotedString]
                              | QuotedString (ControlString QuotedString)* [ControlString]
private QuotedString        ::=	STRING_LITERAL
private ControlString       ::=	controlchar+
private controlchar         ::= CHARNUM NUMBER_INT | CHARNUM NUMBER_HEX // ***===
