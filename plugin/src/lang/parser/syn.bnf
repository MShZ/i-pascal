{
  generateTokens=true
  generatePsi=true
  generateStubParser=true

  parserClass="com.siberika.idea.pascal.lang.parser.PascalParser"
  stubParserClass="com.siberika.idea.pascal.lang.parser.PascalParserUtil"

  implements="com.siberika.idea.pascal.lang.psi.PascalPsiElement"
  extends="com.siberika.idea.pascal.lang.psi.impl.PascalPsiElementImpl"

  psiClassPrefix="Pas"
  psiImplClassSuffix="Impl"
  psiPackage="com.siberika.idea.pascal.lang.psi"
  psiImplPackage="com.siberika.idea.pascal.lang.psi.impl"
  psiImplUtilClass="com.siberika.idea.pascal.lang.psi.impl.PascalPsiImplUtil"

  elementTypeHolderClass="com.siberika.idea.pascal.lang.psi.PasTypes"
  elementTypePrefix=""
  elementTypeClass="com.siberika.idea.pascal.lang.psi.PascalPsiElementType"
  tokenTypeClass="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  tokens = [
        STRING_LITERAL="STRING_LITERAL"

        AND='regexp:(?i)and'
        MOD="regexp:(?i)mod"
        OR="regexp:(?i)or"
        IDIV="regexp:(?i)div"
        SHR="regexp:(?i)shr"
        SHL="regexp:(?i)shl"
        IN='regexp:(?i)in'

        AS="regexp:(?i)as"
        IS="regexp:(?i)is"
        NIL="regexp:(?i)nil"

        CLASS='regexp:[Cc]lass'
        DISPINTERFACE="regexp:(?i)dispinterface"

        TRY='regexp:(?i)try'
        RAISE='regexp:[Rr]aise'
        EXCEPT="regexp:(?i)except"
        ON="regexp:(?i)on"
        FINALLY="regexp:(?i)finally"

        PROGRAM="regexp:(?i)program"
        UNIT='regexp:[Uu]nit'
        LIBRARY="regexp:(?i)library"
        PACKAGE="regexp:(?i)package"
        USES='regexp:[Uu]ses'
        EXPORTS="regexp:(?i)exports"
        FINALIZATION="regexp:(?i)finalization"
        INITIALIZATION="regexp:(?i)initialization"

        THREADVAR="regexp:(?i)threadvar"
        ABSOLUTE="regexp:(?i)absolute"
        OUT="regexp:(?i)out"
        CONSTREF="regexp:(?i)constref"
        RESOURCESTRING='regexp:[Rr]esource[Ss]tring'
        INLINE="regexp:(?i)inline"
        PACKED="regexp:(?i)packed"
        PROPERTY="regexp:(?i)property"
        SET="regexp:(?i)set"
        FILE="regexp:(?i)file"

        ASM="regexp:(?i)asm"
        GOTO="regexp:(?i)goto"
        LABEL="regexp:(?i)label"
        WITH='regexp:[Ww]ith'
        EXIT="regexp:(?i)exit"
        CONTINUE="regexp:(?i)continue"
        BREAK="regexp:(?i)break"

        CONSTRUCTOR='regexp:[Cc]onstructor'
        DESTRUCTOR='regexp:[Dd]estructor'
        INHERITED="regexp:(?i)inherited"
        OBJECT="regexp:(?i)object"
        OPERATOR="regexp:(?i)operator"
        REINTRODUCE="regexp:(?i)reintroduce"
        SELF="regexp:(?i)self"

        NOT='regexp:(?i)not'
        XOR="regexp:(?i)xor"

        TO='regexp:(?i)to'
        DOWNTO="regexp:(?i)downto"
        REPEAT='regexp:[Rr]epeat'

        STATIC="regexp:(?i)static"
        SEALED="regexp:(?i)sealed"
        FINAL="regexp:(?i)final"
        HELPER="regexp:(?i)helper"
        EXPORT="regexp:(?i)export"
        DISPID="regexp:(?i)dispid"
        ABSTRACT="regexp:(?i)abstract"

        STRICT="regexp:(?i)strict"
        PUBLISHED="regexp:(?i)published"
        PUBLIC="regexp:(?i)public"
        PROTECTED="regexp:(?i)protected"
        PRIVATE="regexp:(?i)private"
        AUTOMATED="regexp:(?i)automated"

        MESSAGE="regexp:(?i)message"
        FORWARD="regexp:(?i)forward"
        EXTERNAL="regexp:(?i)external"
        EXPERIMENTAL="regexp:(?i)experimental"
        DEPRECATED="regexp:(?i)deprecated"
        ASSEMBLER="regexp:(?i)assembler"

        INDEX="regexp:(?i)index"
        DEFAULT="regexp:(?i)default"

        VIRTUAL="regexp:(?i)virtual"
        DYNAMIC="regexp:(?i)dynamic"
        OVERRIDE="regexp:(?i)override"
        OVERLOAD="regexp:(?i)overload"

        REGISTER="regexp:(?i)register"
        STDCALL="regexp:(?i)stdcall"
        PLATFORM="regexp:(?i)platform"
        PASCAL="regexp:(?i)pascal"
        CDECL="regexp:(?i)cdecl"
        SAFECALL="regexp:(?i)safecall"

        REFERENCE="regexp:(?i)reference"

        IMPLEMENTS="regexp:(?i)implements"
        REQUIRES="regexp:(?i)requires"
        CONTAINS="regexp:(?i)contains"

        FALSE='regexp:(?i)false'
        TRUE='regexp:(?i)true'

        INTERFACE="regexp:(?i)interface"
        IMPLEMENTATION="regexp:(?i)implementation"

        VAR='regexp:(?i)var'
        CONST='regexp:(?i)const'
        TYPE="regexp:(?i)type"
        ARRAY='regexp:(?i)array'
        RECORD='regexp:(?i)record'
        PROCEDURE='regexp:(?i)procedure'
        FUNCTION='regexp:[Ff]unction'
        OF="regexp:(?i)of"

        CASE="regexp:(?i)case"
        BEGIN='regexp:(?i)begin'
        END='regexp:(?i)end'
        FOR='regexp:(?i)for'
        UNTIL='regexp:(?i)until'
        WHILE='regexp:(?i)while'
        DO='regexp:(?i)do'
        IF='regexp:(?i)if'
        THEN='regexp:(?i)then'
        ELSE="regexp:(?i)else"

        READ="regexp:(?i)read"
        WRITE="regexp:(?i)write"

        POWER="**"
        MULT="*"
        PLUS="+"
        MINUS="-"
        DIV="/"
        SEMI=";"
        COMMA=","
        LPAREN="("
        RPAREN=")"
        LBRACK="["
        RBRACK="]"
        EQ="="
        LT="<"
        GT=">"
        GE=">="
        LE="<="
        NE="<>"
        COLON=":"
        ASSIGN=":="
        DOT="."
        DEREF="^"
        AT="@"
        HEXNUM="$"
        CHARNUM="#"
        KEYWORDESCAPE="&"

        INCLUDE="include"
        CT_DEFINE="ct_define"
        CT_UNDEFINE="ct_undefine"
        CT_IFDEF="ct_ifdef"
        CT_IFNDEF="ct_ifndef"
        CT_ELSE="ct_else"
        CT_ENDIF="ct_endif"
        COMP_OPTION="comp_option"

        COMMENT='regexp:\{[^}]*\}'
        COMMENT='regexp://.*'
        COMMENT='regexp:\(\*(.*\n)*.*\*\)'
        NAME='regexp:[_A-Za-z]\w*'
        RANGE='..'
        STRING_LITERAL="regexp:'[^']*'"
        NUMBER_INT='regexp:[0-9]+'
        NUMBER_REAL='regexp:[0-9]+(.[0-9]+)?'
        NUMBER_HEX='regexp:\$[0-9abcdefABCDEF]+'
        WHITESPACE='regexp:[\ \n\r\t\f]'
  ]

  implements(".*QualifiedIdent|NamespaceIdent")="com.siberika.idea.pascal.lang.psi.PascalQualifiedIdent"
  implements(".*ModuleHead|.*Ident|ClassProperty|FormalParameter")="com.siberika.idea.pascal.lang.psi.PascalNamedElement"
  extends(".*ModuleHead|.*Ident|ClassProperty|FormalParameter")="com.siberika.idea.pascal.lang.psi.impl.PascalNamedElementImpl"
  extends("ClassTypeDecl|ObjectDecl|ClassHelperDecl|InterfaceTypeDecl|RecordDecl|RecordHelperDecl")="com.siberika.idea.pascal.lang.psi.impl.PasEntityScopeImpl";
}

//external pascal             ::= parsePascal Module
Module                      ::= moduleUnit | ModuleProgram | moduleLibrary | modulePackage
                            {extends="com.siberika.idea.pascal.lang.psi.impl.PascalModuleImpl"
                             implements="com.siberika.idea.pascal.lang.psi.PasEntityScope"}

ModuleProgram               ::= progWithHead | progWoHead
private progWithHead        ::= ProgramModuleHead progWoHead
private progWoHead          ::= [UsesFileClause] BlockGlobal "."

private moduleUnit          ::= UnitModuleHead UnitInterface UnitImplementation "."
UnitModuleHead              ::= UNIT NamespaceIdent HintingDirective* ";" {pin=1 recoverWhile=rec_module}
UsesClause                  ::= USES namespaceNameList {pin=1 recoverWhile=rec_section}

private moduleLibrary       ::= LibraryModuleHead [UsesFileClause] BlockGlobal "." {pin=1}
LibraryModuleHead           ::= LIBRARY NamespaceIdent HintingDirective* ";" {pin=1}

private modulePackage       ::= PackageModuleHead RequiresClause [ContainsClause] END "." {pin=1}
PackageModuleHead           ::= PACKAGE NamespaceIdent ";" {pin=1}
RequiresClause              ::= REQUIRES namespaceNameList {pin=1}
ContainsClause              ::= CONTAINS namespaceFileNameList {pin=1}

UnitInterface               ::= INTERFACE [UsesClause] interfaceDecl* {pin=1 recoverWhile=rec_interface name="interface section"}
private rec_module          ::= !(INTERFACE) & rec_interface
private rec_interface       ::= !(IMPLEMENTATION) & rec_implementation
private rec_implementation  ::= !(INITIALIZATION | FINALIZATION | ".")
private rec_section         ::= !(CLASS | TYPE | varKey | constKey | rec__routine_key | IMPLEMENTATION | END)

    private rec__local_decl          ::= '.' | BEGIN | varKey | rec__routine_key | constKey | PROPERTY | TYPE | LABEL
    private rec__global_decl         ::= rec__local_decl | FINALIZATION | INITIALIZATION | END
                                  | CLASS | EXPORTS | INTERFACE | IMPLEMENTATION | USES | CONTAINS | REQUIRES
    private rec__routine_key         ::= PROCEDURE | FUNCTION | CONSTRUCTOR | DESTRUCTOR | OPERATOR

    private rec_statement   ::= !(';' | rec__block_end | rec__stmt_start | rec__stmt_middle | rec__block_start | varKey | constKey | TYPE | procKey)

    private rec__stmt_start          ::= REPEAT | WHILE | FOR | CASE | WITH | RAISE | IF | TRY | BEGIN | BREAK | CONTINUE | EXIT | GOTO | INHERITED
                                  | NUMBER_INT | NUMBER_HEX | NUMBER_REAL | identifier | Ident_kw | KEYWORDESCAPE | '^' | '.' | '[' | '('
    private rec__stmt_middle         ::= DO | ELSE | THEN
    private rec__block_start         ::= BEGIN | INITIALIZATION | FINALIZATION
    private rec__block_end           ::= END | UNTIL | EXCEPT | FINALLY
    private rec__after_expr          ::= TO | DO | THEN | OF | DOWNTO | EXCEPT | INDEX | ELSE
                                  | "name" | OVERLOAD | inlineDirective | callConvention | oldCallConventionDirective
                                  | DEPRECATED | EXPERIMENTAL | PLATFORM | LIBRARY | "varargs" | EXTERNAL | "unsafe"
                                  | REINTRODUCE | bindingDirective | abstractDirective | ClassPropertySpecifier
    private rec_expression ::= !(';' | relOp | mulOp | addOp | END | ')' | ',' | ']' | ':' | after_expr)


private interfaceDecl       ::= commonDecl | routineDecl | exportsSection | assemblyAttribute {recoverWhile=rec_section}
private assemblyAttribute   ::= "[" "assembly" ":" CustomAttributeDecl "]" {pin=2}
private exportsSection      ::= EXPORTS identifier exportItem ("," identifier exportItem)* ";" {pin=1}
private exportItem          ::= ["(" [FormalParameterList] ")"] [INDEX Expression] ["name" Expression] ["resident"]

private operatorRedef       ::= ASSIGN | PLUS | MINUS | MULT | DIV | POWER | EQ | LT | LE | GT | GE
private procName            ::= ClassQualifiedIdent | NamedIdent
private methodKey           ::= [CLASS] PROCEDURE | CONSTRUCTOR | DESTRUCTOR | CLASS OPERATOR
private procKey             ::= FUNCTION | PROCEDURE

ExportedRoutine             ::= routineDeclaration {extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl"}
private routineDeclaration  ::= [CustomAttribute] (exportedProc | exportedFunc | operatorDecl) ";" functionDirective* {pin=2}
private exportedFunc        ::= [CLASS] FUNCTION procName [GenericDefinition] [FormalParameterSection] ":" [CustomAttribute] TypeDecl {pin=2}
private exportedProc        ::= methodKey procName [GenericDefinition] [FormalParameterSection] {pin=1}
private operatorDecl        ::= OPERATOR operatorRedef FormalParameterSection [NamedIdent] ":" TypeDecl {pin=1}

RoutineImplDecl             ::= routineDeclaration ProcBodyBlock {pin=1 name="procedure or function declaration"
                                 extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl" implements="com.siberika.idea.pascal.lang.psi.PascalNamedElement"}
MethodImplDecl              ::= routineDeclaration [MethodBody]     //TODO: remove
                                {extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl" implements="com.siberika.idea.pascal.lang.psi.PascalNamedElement"}
ClassMethodResolution       ::= [CLASS] procKey GenericTypeIdent "." identifier "=" identifier ";"
ClassMethod                 ::= routineDeclaration {name="method declaration" extends="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl"}  //TODO: remove

ProcedureReference          ::= REFERENCE TO procedureTypeHeading {pin=1}
private procedureTypeHeading ::= funcHeading | procHeading;
private funcHeading         ::= FUNCTION [FormalParameterSection] ":" [CustomAttribute] TypeDecl [";" callConvention+] {pin=1}
private procHeading         ::= PROCEDURE [FormalParameterSection] {pin=1}

ClosureExpression           ::= (funcHeading | procHeading) BlockGlobal

private complexType         ::= [PACKED] complexTypePart
private complexTypePart     ::= ClassTypeTypeDecl | structTypeDecl | ArrayType | SetType | FileType
private structTypeDecl      ::= ClassHelperDecl | ClassTypeDecl | InterfaceTypeDecl | ObjectDecl | RecordHelperDecl | RecordDecl

private routineDecl         ::= ExportedRoutine | ClassMethodResolution | ClassMethod
private commonDecl          ::= [CLASS] ClassProperty | ConstSection | TypeSection | [CLASS] VarSection
private structItem          ::= commonDecl | routineDecl | ClassField | Visibility
DeclSection	                ::=	MethodImplDecl | RoutineImplDecl | commonDecl | LabelDeclSection | exportsSection | assemblyAttribute

UnitImplementation          ::= IMPLEMENTATION [UsesClause] ImplDeclSection unitBlock {pin=1 recoverWhile=rec_implementation name="implementation section"}
ImplDeclSection             ::= DeclSection* {}
private unitBlock           ::= [UnitInitialization] [UnitFinalization] END | CompoundStatement | END {}
UnitInitialization          ::= INITIALIZATION StatementList {pin=1 name="initialization section"}
UnitFinalization            ::= FINALIZATION StatementList  {pin=1 name="finalization section"}

ProgramModuleHead	        ::= PROGRAM NamespaceIdent ProgramParamList? ";" {pin=1 }
ProgramParamList            ::= LPAREN progParam? progParamsRest* RPAREN {pin=1}
private progParamsRest      ::= "," progParam {pin=1}
private progParam           ::= identifier {}

UsesFileClause	            ::=	USES namespaceFileNameList {pin=1 name="uses clause"}
private namespaceFileNameList ::= namespaceFileName namespaceFileNamesRest* ";"
private namespaceFileNamesRest ::= COMMA namespaceFileName {pin=1}
private namespaceFileName	::=	NamespaceIdent [IN quotedString] {}

private namespaceNameList   ::= NamespaceIdent namespaceNamesRest* ";"
private namespaceNamesRest  ::= "," NamespaceIdent {pin=1 }

BlockGlobal	                ::=	[';'] DeclSection* BlockBody {pin=2 }
BlockBody	        ::=	CompoundStatement |	AssemblerStatement

AssemblerStatement  ::= ASM assemblerItem* END
private assemblerItem       ::= ',' | '[' | ']' | ':' | '+' | '-' | '*' | '/' | '@' | identifier | NUMBER_INT | NUMBER_HEX | NUMBER_BIN

private functionDirective   ::= overloadDirective | externalDirective | oldCallConventionDirectiveSemi
                              | inlineDirectiveSemi | callConventionSemi | HintingDirective ";"
                              | REINTRODUCE ';' | OVERLOAD ';' | bindingDirective | abstractDirectiveSemi | dispIDDirective {name="routine directive"}
private overloadDirective   ::= OVERLOAD ";"
private oldCallConventionDirectiveSemi ::= oldCallConventionDirective ";"
private oldCallConventionDirective ::= "far" | "local" | "near"
private externalDirective   ::= "varargs" ";" | EXTERNAL ";" | EXTERNAL ConstExpression externalSpecifier* ";"
private externalSpecifier   ::= "name" ConstExpression | INDEX ConstExpression
ProcBodyBlock               ::= ProcForwardDecl | procExternalDecl | BlockGlobal [";"]
private procExternalDecl    ::= EXTERNAL ("name" Expression | INDEX Expression)* functionDirective* {pin=1}
ProcForwardDecl             ::= FORWARD ";" functionDirective* {pin=1}

MethodBody          ::= BlockGlobal ";"
private dispIDDirective     ::= DISPID Expression ";" {pin=1}
private callConventionSemi  ::= callConvention ";"
private callConvention      ::= CDECL | PASCAL | REGISTER | SAFECALL | STDCALL | EXPORT
private inlineDirectiveSemi ::= inlineDirective ";"
private inlineDirective     ::= INLINE | ASSEMBLER
private abstractDirectiveSemi ::= abstractDirective ";"
private abstractDirective   ::= ABSTRACT | FINAL
private bindingDirective    ::= ((MESSAGE Expression) | STATIC | DYNAMIC | OVERRIDE | VIRTUAL) ";"

LabelDeclSection	        ::=	LABEL label labelsRest* ";" {pin=1 name="label declaration"}
private labelsRest          ::= "," label {}
private label               ::= identifier | NUMBER_INT | NUMBER_HEX

VarSection	                ::=	varKey varDeclaration+ {pin=1 name="var section"}
private varKey	            ::=	VAR | THREADVAR
private varDeclaration	    ::=	[CustomAttribute] identList ":" TypeDecl [VarValueSpec] HintingDirective* ";" {pin=3 }
VarValueSpec	            ::=	ABSOLUTE identifier | ABSOLUTE ConstExpressionOrd | EQ ConstExpression

ConstSection                ::= constKey constDeclaration+ {pin=1 name="const section"}
private constKey            ::= CONST |	RESOURCESTRING
private constDeclaration    ::= [CustomAttribute] NamedIdent [":" TypeDecl] "=" ConstExpression HintingDirective* ";" {pin=2 }
NamedIdent                  ::= identifier

TypeSection                 ::= TYPE TypeDeclaration+ {pin=1 name="type section"}
TypeDeclaration             ::= [CustomAttribute] GenericTypeIdent "=" TypeDecl HintingDirective* ";" {pin=3 }
GenericTypeIdent    ::= identifier [GenericDefinition]
GenericDefinition   ::= SimpleGenericDefinition | ConstrainedGenericDefinition
SimpleGenericDefinition ::= "<" identifier IdentsRest* ">" {pin=1}                     //TODO use meta rule
IdentsRest          ::= "," identifier {pin=1}
ConstrainedGenericDefinition ::= "<" ConstrainedGeneric ConstrainedGenericsRest ">" {pin=1}
ConstrainedGeneric  ::= identifier [ ":" GenericConstraint GenericConstraintsRest ]
GenericConstraint   ::= identifier | RECORD | CLASS | CONSTRUCTOR
GenericConstraintsRest ::= "," GenericConstraint {pin=1}
ConstrainedGenericsRest ::= ";" ConstrainedGeneric {pin=1}
GenericPostfix      ::=	"<" TypeDecl TypeDeclsRest* ">" {pin=1}
TypeDeclsRest       ::= "," TypeDecl {pin=1}

TypeID              ::=	FullyQualifiedIdent

TypeDecl	                ::=	complexType | PointerType | ProcedureType | stringType | SimpleType | [TYPE] TypeID [GenericPostfix] | variantType

ClassField                  ::= field ';' //TODO: remove ";"

ClassTypeDecl               ::= CLASS (classBody | [ClassParent]) {pin=1 name="class declaration"}
private classBody           ::= [ClassState] [ClassParent] structItem* END
ClassHelperDecl             ::= CLASS HELPER [ClassParent] FOR TypeID structItem* END {pin=2 name="class helper declaration"}
InterfaceTypeDecl           ::= interfaceKey [ClassParent] [interfaceGuid] structItem* END
                              | interfaceKey [ClassParent] {pin(".*")=interfaceKey name="interface declaration"}
ObjectDecl                  ::= OBJECT [ClassParent] structItem* END {pin=1 name="object declaration"}
RecordDecl                  ::= variantRecord | simpleRecord {name="record declaration"}
private simpleRecord        ::= RECORD recordFieldSemi* structItem* END {pin=1}
private variantRecord       ::= RECORD recordFieldSemi* recordVariantSection END
private recordFieldSemi     ::= ClassField {}
private field               ::= [CustomAttribute] identList ":" TypeDecl HintingDirective* {pin=3}
RecordFields        ::= [field] (';' field)* [';']  //===***
private recordVariantSection ::= CASE [identifier ":"] TypeDecl OF (recordVariant | ";" )+ {pin=1}
private recordVariant       ::= ConstExpression ("," ConstExpression)* ":" "(" RecordFields ")" {pin=3}

RecordHelperDecl            ::= RECORD HELPER FOR TypeID structItem* END {pin=2}

ClassState          ::= SEALED | ABSTRACT

ClassParent         ::= "(" TypeID ("," TypeID)* ")" {pin=1}

private interfaceGuid       ::= "[" quotedString "]" {pin=1}
private interfaceKey        ::= INTERFACE | DISPINTERFACE

ClassTypeTypeDecl           ::= CLASS OF TypeID {pin(".*")="class of" name="metaclass declaration"}

Visibility                  ::= [STRICT] PRIVATE | [STRICT] PROTECTED | PUBLIC | PUBLISHED | AUTOMATED


ClassProperty ::= [CustomAttribute] [CLASS] PROPERTY NamedIdent [ClassPropertyArray] [":" TypeID] [ClassPropertyIndex] ClassPropertySpecifier* ";" {pin=3}
ClassPropertyArray ::= "[" FormalParameterList "]" {pin=1}
ClassPropertyIndex ::= INDEX ConstExpressionOrd {pin=1}
ClassPropertySpecifier ::= ClassPropertyReadWrite | ClassPropertyDispInterface | "stored" Expression
                                 | DEFAULT Expression | ';' DEFAULT | "nodefault" | IMPLEMENTS TypeID
ClassPropertyReadWrite ::= READ RefNamedIdent | WRITE RefNamedIdent | "add" RefNamedIdent | "remove" RefNamedIdent
RefNamedIdent       ::= identifier
ClassPropertyDispInterface ::= "readonly" ";" | "writeonly" ";" | dispIDDirective

ArrayType           ::= ARRAY [ArrayIndexes] OF ArraySubType {pin=1}
ArrayIndexes ::= "[" [ArrayIndex] ArrayIndexRest* "]" {pin=1}
ArrayIndex          ::= SubRangeType | TypeID     //TODO: TypeID only?
ArrayIndexRest      ::= "," [ArrayIndex] {pin=1}
ArraySubType        ::= CONST | TypeDecl

SetType             ::= SET OF TypeDecl {pin=1}
FileType            ::= FILE [OF TypeDecl] {pin=1}
PointerType         ::= "^" TypeDecl {pin=1}

private stringType          ::= "string" ["[" Expression "]"] | "AnsiString" [codePageNumber]
private codePageNumber      ::= "(" ConstExpressionOrd ")" {pin=1}
private variantType         ::= identifier

ProcedureType       ::= MethodType | SimpleProcedureType | ProcedureReference
SimpleProcedureType ::= procedureTypeHeading
MethodType          ::= procedureTypeHeading OF OBJECT {pin=3}

SimpleType          ::= EnumType | SubRangeType
SubRangeType        ::= RangeBound RANGE RangeBound
RangeBound          ::= ConstExpressionOrd
EnumType            ::= "(" EnumEl EnumRest* ")" {pin=1}
EnumRest            ::= "," EnumEl {pin=1}
EnumEl              ::= identifier ["=" Expression] {}

CompoundStatement           ::= BEGIN [StatementList] END {pin=1}
StatementList               ::= [statement] statements* {}
private statements          ::= ";" [statement] {}
private statement           ::= [LabelId ":" ] statementPart
private statementPart       ::= RepeatStatement | WhileStatement | ForStatement
                              | CaseStatement | WithStatement | RaiseStatement | AssemblerStatement
                              | CompoundStatement | IfStatement | TryStatement | simpleStatement | stmtEmpty

private simpleStatement     ::= GotoStatement | StmtSimpleOrAssign
StmtSimpleOrAssign          ::= Designator [assignPart]
assignOp                    ::= ":=" | "+=" | "-=" | "*=" | "/="
assignPart                  ::= assignOp (NewStatement | Expression) {pin=1 }
NewStatement                ::= NEW "(" [ Expression ] ("," [ Expression ])* [ "," ConstExpression ] ")"// {pin=1 }
stmtEmpty           ::= //empty

EntityID                    ::= FullyQualifiedIdent
FieldId                     ::= identifier

RepeatStatement     ::= REPEAT [StatementList] UNTIL Expression {pin=1}
WhileStatement      ::= WHILE Expression DO statement {pin=1}
ForStatement        ::= FOR Designator (ForCycle | IN) Expression DO statement {pin=1}
ForCycle    ::= ":=" Expression (TO | DOWNTO)

IfStatement                 ::= IF Expression THEN statement [ELSE statement] {pin=1}

CaseStatement       ::= CASE Expression OF CaseItem* [ELSE StatementList [";"] ] END {pin=1}
CaseItem	        ::=	CaseLabel ("," CaseLabel)* ":" statement [";"] {pin=3}
CaseLabel	        ::=	ConstExpressionOrd [RANGE ConstExpressionOrd] //{}

TryStatement                ::= TRY StatementList (tryExcept | tryFinally) END {pin=1}
private tryFinally          ::= FINALLY StatementList
private tryExcept           ::= EXCEPT HandlerList
HandlerList                 ::= Handler+ [ELSE StatementList] | StatementList
Handler                     ::= ON identifier ":" TypeID "do" statement ";" {pin=1}

WithStatement               ::= WITH Designator designatorsRest* DO statement {pin=1}
private designatorsRest     ::= "," Designator {}

RaiseStatement              ::= RAISE [Designator] ["at" Designator] {pin=1}

GotoStatement               ::= GOTO LabelId | EXIT [ "(" Expression ")" ] | BREAK | CONTINUE

LabelId                     ::= identifier | NUMBER_INT

SetSection                  ::=	"[" [ExpressionOrd SetRest*] "]"// {pin=1}
SetRest             ::= ("," | RANGE | ) ExpressionOrd //{}

ClassQualifiedIdent         ::= SubIdent "." SubIdent
FullyQualifiedIdent	        ::=	namespacePart? SubIdent
NamespaceIdent	            ::=	namespacePart? SubIdent
SubIdent                    ::= identifier
private namespacePart       ::= namespaceItem+
private namespaceItem       ::= SubIdent "."// {pin=2 }

HintingDirective            ::= (DEPRECATED [StringFactor]) | EXPERIMENTAL | PLATFORM | LIBRARY// {}
//recover_hintingDir          ::= !(';' | ')' | END | global_decl)

Ident_kw                    ::= OUT | EXIT | BREAK | CONTINUE | OPERATOR | SELF | NEW | REINTRODUCE | OVERLOAD | MESSAGE |STATIC | DYNAMIC
                              | OVERRIDE | VIRTUAL | ABSTRACT | SEALED | FINAL | ASSEMBLER | CDECL | PASCAL | REGISTER | SAFECALL | STDCALL
                              | EXPORT | STRICT | PRIVATE | PROTECTED | PUBLIC | PUBLISHED | AUTOMATED | DISPID | EXTERNAL | FORWARD | HELPER
                              | DEFAULT | IMPLEMENTS | INDEX | READ | WRITE | DEPRECATED | EXPERIMENTAL | PLATFORM | REFERENCE
                              | PACKAGE | CONTAINS | REQUIRES | INCLUDE
private identifier          ::= KEYWORDESCAPE ReservedWord | Ident_kw | NAME
ReservedWord	            ::=	NAME //===***
private identList	        ::=	identListItem identListRest*
private identListRest       ::= "," identListItem {pin=1}
private identListItem       ::= NamedIdent

ConstExpressionOrd          ::=	ExpressionOrd {name="integer constant expression"}
ConstExpression	            ::=	Expression | NewConstExpression | RecordConstExpression {name="constant expression"}
NewConstExpression	        ::=	LPAREN ConstExpression (COMMA ConstExpression)* RPAREN | Expression
RecordConstExpression       ::= Expression | RecordConstValue;
RecordConstValue            ::= "(" recordValue recordValueRest* ")" {pin=1}
private recordValueRest     ::= ";" recordValue
private recordValue         ::= identifier ":" RecordConstExpression

Designator                  ::= //[ "inherited" ] , [ QualifiedIdent | TypeID ] , { DesignatorItem } ===***
                                INHERITED [TypeID] DesignatorItem2? | EntityID DesignatorItemEx* | DesignatorItemEx+

DesignatorItem      ::= "^" | "." FieldId | "[" ExpressionsList "]"
DesignatorItemEx    ::= DesignatorItem | DesignatorItem2
DesignatorItem2     ::= "(" [ExpressionColon ExpressionColons*] ")"// {pin=1}
ExpressionColon     ::= Expression [ColonConstruct] {}
ExpressionColons    ::= "," ExpressionColon
ColonConstruct      ::= ":" Expression [ ":" Expression ]

private primary             ::= AT primary | AT AT primary | NOT primary | PLUS primary | MINUS primary
                              | NUMBER_INT | NUMBER_REAL | NUMBER_HEX | NUMBER_BIN | TRUE | FALSE | NIL
                              | StringFactor | SetSection | Designator

primaryOrd                  ::= NOT primaryOrd | PLUS primaryOrd | MINUS primaryOrd | NUMBER_INT | NUMBER_HEX | TRUE | FALSE | NIL
                              | "(" ExpressionOrd ")" | StringFactor | Designator

private relOp               ::= "<" | ">" | "<=" | ">=" | "<>" | "=" | IN | IS
private addOp               ::=	PLUS | MINUS | OR | XOR
private mulOp               ::= "*" | "/" | IDIV | MOD | AND | SHL | SHR | AS

Expression ::= ClosureExpression | expr_rel
private expr_rel            ::= expr_sum relOpRest*
private relOpRest           ::= relOp expr_sum {pin=1 }
private expr_sum            ::= expr_product addOpRest*
private addOpRest           ::= addOp expr_product {pin=1 }
private expr_product        ::= primary mulOpRest*
private mulOpRest           ::= mulOp primary {pin=1 }

ExpressionOrd ::= expr_relOrd
private expr_relOrd ::= expr_sumOrd (relOp expr_sumOrd)*
private expr_sumOrd ::= expr_productOrd (addOp expr_productOrd)*
private expr_productOrd ::= primaryOrd (mulOp primaryOrd)*

/*expression ::= factor add_expression * {recoverWhile="expression_recover"}
private factor ::= primary mul_expression *
private primary ::= literal_expression | reference_expression qreference_expression *

left add_expression ::= '+' factor
left mul_expression ::= '*' primary

identifier ::= id
reference_expression ::= identifier {mixin="mypackage.MyReferenceExpressionImpl"}
left qreference_expression ::= '.' identifier {elementType="reference_expression"}

literal_expression ::= number | string*/

FormalParameterSection      ::= "(" [ FormalParameterList ] ")"
FormalParameterList         ::= FormalParameter (";" FormalParameter)*
FormalParameter             ::= [ CustomAttribute ] [ ParamType ] identList [ ":" TypeDecl ] [ "=" Expression ]
ParamType                    ::= CONST | VAR | OUT | CONSTREF//ParmType


ExpressionsList	            ::= Expression (COMMA Expression)*

CustomAttribute	            ::=	LBRACK CustomAttributeDecl RBRACK | assemblyAttribute
CustomAttributeDecl         ::= FullyQualifiedIdent LPAREN ExpressionsList RPAREN
StringFactor                ::= controlString (quotedString controlString)* [quotedString]
                              | quotedString (controlString quotedString)* [controlString]
private quotedString        ::=	STRING_LITERAL
private controlString       ::=	controlchar+
private controlchar         ::= CHARNUM NUMBER_INT | CHARNUM NUMBER_HEX // ***===
