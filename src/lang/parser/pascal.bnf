{
  generateTokens=true
  generatePsi=true
  generateStubParser=true

  parserClass="com.siberika.idea.pascal.lang.parser.PascalParser"
  stubParserClass="com.siberika.idea.pascal.lang.parser.PascalParserUtil"

  implements="com.siberika.idea.pascal.lang.psi.PascalPsiElement"
  extends="com.siberika.idea.pascal.lang.psi.impl.PascalPsiElementImpl"

  psiClassPrefix="Pas"
  psiImplClassSuffix="Impl"
  psiPackage="com.siberika.idea.pascal.lang.psi"
  psiImplPackage="com.siberika.idea.pascal.lang.psi.impl"
  psiImplUtilClass="com.siberika.idea.pascal.lang.psi.impl.PascalPsiImplUtil"

  elementTypeHolderClass="com.siberika.idea.pascal.lang.psi.PasTypes"
  elementTypePrefix=""
  elementTypeClass="com.siberika.idea.pascal.lang.psi.PascalPsiElementType"
  tokenTypeClass="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  tokens = [
      COMMENT="COMMENT"
      STRING_LITERAL="STRING_LITERAL"

      AND="and"
      MOD="mod"
      OR="or"
      IDIV="div"
      SHR="shr"
      SHL="shl"
      IN="in"

      AS="as"


    IS="is"
    NIL="nil"

    CLASS="class"
    DISPINTERFACE="dispinterface"

    TRY="try"
    RAISE="raise"
    EXCEPT="except"
    ON="on"
    FINALLY="finally"

    PROGRAM="program"
    LIBRARY="library"
    PACKAGE="package"
    USES="uses"
    EXPORTS="exports"
    FINALIZATION="finalization"
    INITIALIZATION="initialization"

    THREADVAR="threadvar"
    ABSOLUTE="absolute"
    OUT="out"
    RESOURCESTRING="resourcestring"
    INLINE="inline"
    PACKED="packed"
    PROPERTY="property"
    ARRAY="array"
    SET="set"
    FILE="file"
    STRING="string"

    ASM="asm"
    GOTO="goto"
    LABEL="label"
    WITH="with"

    CONSTRUCTOR="constructor"
    DESTRUCTOR="destructor"
    INHERITED="inherited"
    OBJECT="object"
    OPERATOR="operator"
    REINTRODUCE="reintroduce"
    SELF="self"

    NOT="not"
    XOR="xor"

    TO="to"
    DOWNTO="downto"
    REPEAT="repeat"


      FALSE="false"
      TRUE="true"

      INTERFACE="interface"
      IMPLEMENTATION="implementation"

      VAR="var"
      CONST="const"
      TYPE="type"
      ARRAY="array"
      RECORD="record"
      PROCEDURE="procedure"
      FUNCTION="function"
      OF="of"

      CASE="case"
      BEGIN="begin"
      END="end"
      FOR="for"
      UNTIL="until"
      WHILE="while"
      DO="do"
      IF="if"
      THEN="then"
      ELSE="else"

      MULT="*"
      PLUS="+"
      MINUS="-"
      DIV="/"
      SEMI=";"
      COMMA=","
      LPAREN="("
      RPAREN=")"
      LBRACK="["
      RBRACK="]"
      EQ="="
      LT="<"
      GT=">"
      GE=">="
      LE="<="
      NE="<>"
      COLON=":"
      ASSIGN=":="
      DOT="."
      DEREF="^"
      AT="@"
      HEXNUM="$"
      CHARNUM="#"
      KEYWORDESCAPE="&"

  ]

  implements("pProgram")="com.siberika.idea.pascal.lang.psi.PascalNamedElement"
  extends("pProgram")="com.siberika.idea.pascal.lang.psi.impl.PascalNamedElementImpl"

}

external pascal             ::= parsePascal Module
private Module              ::= pProgram | pUnit | pLibrary | pPackage
pPackage                    ::= PACKAGE END // ***===
pLibrary                    ::= LIBRARY END // ***===
pUnit                       ::= UNIT END    // ***===
                                { methods=[getReferences]}

pProgram                    ::= ProgramHead? UsesFileClause? Block DOT
private ProgramHead	            ::=	PROGRAM NamespaceName ProgramParmSeq? SEMI
private ProgramParmSeq	        ::=	LPAREN Ident? (COMMA Ident)* RPAREN

UsesFileClause	            ::=	USES NamespaceFileNameList
private NamespaceFileNameList	    ::=	NamespaceFileName (COMMA NamespaceFileName)* SEMI
NamespaceFileName	        ::=	NamespaceName [IN QuotedString]

Block	                    ::=	DeclSection* BlockBody?
BlockBody	                ::=	CompoundStatement //|	AssemblerStatement

//DeclSection	            ::=	LabelDeclSection | ConstSection | TypeSection | VarSection | MethodDecl | ProcDecl | ExportsSection | AssemblyAttribute
//LabelDeclSection	        ::=	LABEL Label (COMMA Label)* SEMI
DeclSection	                ::=	VarSection {recoverUntil=commonRecover}
commonRecover               ::= !(END | BEGIN | SEMI)
VarSection	                ::=	VarKey VarDeclaration+
VarKey	                    ::=	VAR | THREADVAR
VarDeclaration	            ::=	CustomAttribute? IdentList COLON TypeDecl VarValueSpec? HintingDirective* SEMI
VarValueSpec	            ::=	ABSOLUTE Ident | ABSOLUTE ConstExpression | EQ ConstExpression

//TypeDecl	                ::=	StrucType | PointerType | StringType | ProcedureType | VariantType | SimpleType | TYPE? TypeID GenericPostfix?
TypeDecl	                ::=	TYPE? TypeID //GenericPostfix?
TypeID                      ::=	NamespacedQualifiedIdent

CompoundStatement           ::= BEGIN StatementList? END {pin=2}
StatementList               ::= [Statement] (SEMI [Statement])* {recoverUntil=statement_recover}
private statement_recover   ::= commonRecover
Statement                   ::= [LabelId ":" ] StatementPart

private StatementPart       ::=
//===*** CaseStatement | RepeatStatement | WhileStatement | ForStatement | WithStatement | RaiseStatement | AssemblerStatement |
                                CompoundStatement | IfStatement | TryStatement | SimpleStatement

SimpleStatement             ::= GotoStatement | Designator ":=" Expression | Designator ":=" NewStatement | Designator {pin=":="}

NewStatement                ::= NEW "(" [ Expression ] ("," [ Expression ])* [ "," ConstExpression ] ")"

Designator                  ::= //[ "inherited" ] , [ NamespacedQualifiedIdent | TypeID ] , { DesignatorItem } ===***
                                (INHERITED DesignatorItem* )
                              | ([NamespacedQualifiedIdent | TypeID] DesignatorItem+)
                              | ((NamespacedQualifiedIdent | TypeID) DesignatorItem*)

private DesignatorItem      ::= "^" | "." Ident | "[" ExpressionsList "]" | DesignatorItem2
private DesignatorItem2     ::= "(" [ Expression [ ColonConstruct ] ("," Expression [ ColonConstruct ])* ] ")"

ColonConstruct              ::= ":" Expression [ ":" Expression ]

IfStatement                 ::= IF Expression THEN Statement [ELSE Statement]

TryStatement                ::= TRY StatementList EXCEPT HandlerList END
                              | TRY StatementList FINALLY StatementList END
HandlerList                 ::= (Handler)* [ELSE StatementList] | StatementList
Handler                     ::= ON Ident ":" TypeID "do" Statement ";"

GotoStatement               ::= GOTO LabelId | EXIT [ "(" Expression ")" ] | BREAK | CONTINUE

LabelId                     ::= Ident | NUMBER_INT

NamespacedQualifiedIdent    ::= (NamespaceName DOT)? QualifiedIdent
NamespaceName	            ::=	Ident (DOT Ident)*
QualifiedIdent	            ::=	(Ident DOT)* Ident

HintingDirective            ::= DEPRECATED StringFactor? EXPERIMENTAL |	PLATFORM | LIBRARY

Ident	                    ::= NAME | KEYWORDESCAPE ReservedWord
IdentList	                ::=	Ident (COMMA Ident)*
ReservedWord	            ::=	NAME

ConstExpression	            ::=	LPAREN ConstExpression (COMMA ConstExpression)* RPAREN | Expression
	                        //|	LPAREN RecordConstExpression (SEMI RecordConstExpression)* RPAREN

primary                     ::= AT primary | AT AT primary | NOT primary | PLUS primary | MINUS primary | "^" Ident |
                                NUMBER_INT | NUMBER_REAL | NUMBER_HEX | NUMBER_BIN | TRUE | FALSE | NIL |
                                "(" Expression ")" | StringFactor | SetSection |
                                TypeID "(" Expression ")" | Designator

RelOp                       ::= "<" | ">" | "<=" | ">=" | "<>" | "=" | "in" | "is"
AddOp                       ::=	"+" | "-" | "or" | "xor"
MulOp                       ::= "*" | "/" | "div" | "mod" | "and" | "shl" | "shr" | "as"


Expression ::= expr_rel | ClosureExpression
term ::= "(" Expression ")" | primary
expr_rel ::= expr_sum (RelOp expr_sum) *
expr_sum ::= expr_product (AddOp expr_product) *
expr_product ::= term (MulOp term) *

private expression_recover ::= !(NUMBER_INT | STRING | ID)

/*expression ::= factor add_expression * {recoverUntil="expression_recover"}
private factor ::= primary mul_expression *
private primary ::= literal_expression | reference_expression qreference_expression *

left add_expression ::= '+' factor
left mul_expression ::= '*' primary

identifier ::= id
reference_expression ::= identifier {mixin="mypackage.MyReferenceExpressionImpl"}
left qreference_expression ::= '.' identifier {elementType="reference_expression"}

literal_expression ::= number | string*/

SetSection                  ::=	"[" [ Expression (( "," | ".." ) Expression)* ] "]"

ClosureExpression           ::= PROCEDURE [ FormalParameterSection ] Block | FUNCTION [ FormalParameterSection ] ":" TypeDecl Block
FormalParameterSection      ::= "(" [ FormalParameterList ] ")"
FormalParameterList         ::= FormalParameter (";" FormalParameter)*
FormalParameter             ::= [ CustomAttribute ] [ ParmType ] IdentList [ ":" TypeDecl ] [ "=" Expression ]
ParmType                    ::= CONST | VAR | OUT


ExpressionsList	            ::= Expression (COMMA Expression)*

CustomAttribute	            ::=	LBRACK CustomAttributeDecl RBRACK
                            //| AssemblyAttribute
CustomAttributeDecl         ::= NamespacedQualifiedIdent LPAREN ExpressionsList RPAREN
StringFactor                ::= ControlString (QuotedString ControlString)* [QuotedString]
                              | QuotedString (ControlString QuotedString)* [ControlString]
QuotedString                ::=	STRING_LITERAL
ControlString               ::=	controlchar+
controlchar                 ::= CHARNUM NUMBER_INT | CHARNUM HEXNUM NUMBER_INT // ***===