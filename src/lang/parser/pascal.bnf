{
  generateTokens=true
  generatePsi=true
  generateStubParser=true

  parserClass="com.siberika.idea.pascal.lang.parser.PascalParser"
  stubParserClass="com.siberika.idea.pascal.lang.parser.PascalParserUtil"

  implements="com.siberika.idea.pascal.lang.psi.PascalPsiElement"
  extends="com.siberika.idea.pascal.lang.psi.impl.PascalPsiElementImpl"

  psiClassPrefix="Pas"
  psiImplClassSuffix="Impl"
  psiPackage="com.siberika.idea.pascal.lang.psi"
  psiImplPackage="com.siberika.idea.pascal.lang.psi.impl"
  psiImplUtilClass="com.siberika.idea.pascal.lang.psi.impl.PascalPsiImplUtil"

  elementTypeHolderClass="com.siberika.idea.pascal.lang.psi.PasTypes"
  elementTypePrefix=""
  elementTypeClass="com.siberika.idea.pascal.lang.psi.PascalPsiElementType"
  tokenTypeClass="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  tokens = [
      COMMENT="COMMENT"
      STRING_LITERAL="STRING_LITERAL"

      AND="and"
      MOD="mod"
      OR="or"
      IDIV="div"
      SHR="shr"
      SHL="shl"
      IN="in"

      AS="as"


    IS="is"
    NIL="nil"

    CLASS="class"
    DISPINTERFACE="dispinterface"

    TRY="try"
    RAISE="raise"
    EXCEPT="except"
    ON="on"
    FINALLY="finally"

    PROGRAM="program"
    LIBRARY="library"
    PACKAGE="package"
    USES="uses"
    EXPORTS="exports"
    FINALIZATION="finalization"
    INITIALIZATION="initialization"

    THREADVAR="threadvar"
    ABSOLUTE="absolute"
    OUT="out"
    RESOURCESTRING="resourcestring"
    INLINE="inline"
    PACKED="packed"
    PROPERTY="property"
    ARRAY="array"
    SET="set"
    FILE="file"
    STRING="string"

    ASM="asm"
    GOTO="goto"
    LABEL="label"
    WITH="with"

    CONSTRUCTOR="constructor"
    DESTRUCTOR="destructor"
    INHERITED="inherited"
    OBJECT="object"
    OPERATOR="operator"
    REINTRODUCE="reintroduce"
    SELF="self"

    NOT="not"
    XOR="xor"

    TO="to"
    DOWNTO="downto"
    REPEAT="repeat"


      FALSE="false"
      TRUE="true"

      INTERFACE="interface"
      IMPLEMENTATION="implementation"

      VAR="var"
      CONST="const"
      TYPE="type"
      ARRAY="array"
      RECORD="record"
      PROCEDURE="procedure"
      FUNCTION="function"
      OF="of"

      CASE="case"
      BEGIN="begin"
      END="end"
      FOR="for"
      UNTIL="until"
      WHILE="while"
      DO="do"
      IF="if"
      THEN="then"
      ELSE="else"

      MULT="*"
      PLUS="+"
      MINUS="-"
      DIV="/"
      SEMI=";"
      COMMA=","
      LPAREN="("
      RPAREN=")"
      LBRACK="["
      RBRACK="]"
      EQ="="
      LT="<"
      GT=">"
      GE=">="
      LE="<="
      NE="<>"
      COLON=":"
      ASSIGN=":="
      DOT="."
      DEREF="^"
      AT="@"
      HEXNUM="$"
      CHARNUM="#"
      KEYWORDESCAPE="&"

  ]

  implements("pProgram")="com.siberika.idea.pascal.lang.psi.PascalNamedElement"
  extends("pProgram")="com.siberika.idea.pascal.lang.psi.impl.PascalNamedElementImpl"

}

external pascal             ::= parsePascal Module
private Module              ::= pProgram// | pUnit | pLibrary | pPackage
private moduleRecover       ::= !(USES | BEGIN | VAR | THREADVAR)

pPackage                    ::= PACKAGE END // ***===
pLibrary                    ::= LIBRARY END // ***===
pUnit                       ::= UNIT END    // ***===
                                { methods=[getReferences]}

pProgram                    ::= ProgramHead? UsesFileClause? Block "."
private ProgramHead	        ::=	PROGRAM NamespaceName ProgramParamList? SEMI// {recoverUntil=moduleRecover pin=1}
ProgramParamList            ::= LPAREN progParam? progParamsRest* RPAREN {pin=1}
private progParamsRest      ::= "," progParam {pin=1}
private progParam           ::= Ident {recoverUntil=recover_commaList}

UsesFileClause	            ::=	USES NamespaceFileNameList
private NamespaceFileNameList ::= NamespaceFileName NamespaceFileNamesRest* SEMI
private NamespaceFileNamesRest ::= COMMA NamespaceFileName {pin=1}
private NamespaceFileName	::=	NamespaceName [IN QuotedString] {recoverUntil=recover_commaList}
private recover_commaList   ::= !(SEMI | RPAREN | COMMA | COLON | DOT | "]" | "..")

Block	                    ::=	DeclSection* BlockBody? {pin=2}
private BlockBody	        ::=	CompoundStatement //|	AssemblerStatement
                      //DeclSection	            ::=	LabelDeclSection | ConstSection | TypeSection | VarSection | MethodDecl | ProcDecl | ExportsSection | AssemblyAttribute
//LabelDeclSection	        ::=	LABEL Label (COMMA Label)* SEMI
private DeclSection	        ::=	VarSection
VarSection	                ::=	VarKey VarDeclaration+
private VarKey	            ::=	VAR | THREADVAR
private VarDeclaration	    ::=	CustomAttribute? IdentList COLON TypeDecl VarValueSpec? HintingDirective* SEMI
VarValueSpec	            ::=	ABSOLUTE Ident | ABSOLUTE ConstExpression | EQ ConstExpression

//TypeDecl	                ::=	StrucType | PointerType | StringType | ProcedureType | VariantType | SimpleType | TYPE? TypeID GenericPostfix?
TypeDecl	                ::=	TYPE? TypeID //GenericPostfix?
TypeID              ::=	NamespacedQualifiedIdent

CompoundStatement           ::= BEGIN StatementList? END
private StatementList       ::= [Statement] Statements*
private Statements          ::= SEMI [Statement]  {recoverUntil=recover_statement}
private recover_statement   ::= !(SEMI | ':=' | ';' | DOT | IF | TRY | PROCEDURE | FUNCTION | TYPE | VAR | CONST | END | EXCEPT | FINALLY)
private Statement           ::= [LabelId ":" ] StatementPart

private StatementPart       ::=
//===*** CaseStatement | RepeatStatement | WhileStatement | ForStatement | WithStatement | RaiseStatement | AssemblerStatement |
                                CompoundStatement | IfStatement | TryStatement | SimpleStatement | stmtEmpty
private stmtEmpty           ::= //empty

SimpleStatement             ::= GotoStatement | stmtAssign | Designator
private stmtAssign          ::= stmtAssign1 | Designator ":=" NewStatement
private stmtAssign1         ::= Designator ":=" Expression {pin=2}

NewStatement                ::= NEW "(" [ Expression ] ("," [ Expression ])* [ "," ConstExpression ] ")"

Designator                  ::= //[ "inherited" ] , [ NamespacedQualifiedIdent | TypeID ] , { DesignatorItem } ===***
                                [INHERITED] (TypeID DesignatorItem*) | DesignatorItem+

DesignatorItem      ::= "^" | "." Ident | "[" ExpressionsList "]" | DesignatorItem2
DesignatorItem2     ::= "(" [ ExpressionColon ExpressionColons* ] ")" {pin=1}
private ExpressionColon ::= Expression [ ColonConstruct ] {recoverUntil=recover_commaList}
private ExpressionColons ::= "," ExpressionColon

ColonConstruct              ::= ":" Expression [ ":" Expression ]

IfStatement                 ::= IF Expression THEN Statement [ELSE Statement] {pin=1}

TryStatement                ::= TryExcept | TryFinally
private TryFinally          ::= TRY StatementList FINALLY StatementList END {pin=1}
private TryExcept           ::= TRY StatementList EXCEPT HandlerList END {pin=1}
HandlerList                 ::= Handler+ [ELSE StatementList] | StatementList
Handler                     ::= ON Ident ":" TypeID "do" Statement ";"

GotoStatement               ::= GOTO LabelId | EXIT [ "(" Expression ")" ] | BREAK | CONTINUE

LabelId                     ::= Ident | NUMBER_INT

NamespacedQualifiedIdent ::= NamespaceName//(NamespaceName DOT)? QualifiedIdent
//QualifiedIdent	    ::=	(Ident ".")* Ident//IdentDot* NamespaceItem
NamespaceName	            ::=	NamespaceItem DotIdent* {recoverUntil=recover_dotList1}
DotIdent            ::= "." NamespaceItem {pin=1}
NamespaceItem       ::= Ident
private recover_dotList1     ::= !("," | SEMI | NUMBER_INT| STRING_LITERAL | ":=" | "^" | "[" | "]" | "(" | ")" | RelOp | AddOp | MulOp | recover_part_statement)
private recover_part_statement ::= (DO | THEN | ELSE | UNTIL | TO | DOWNTO | EXCEPT | FINALLY | END)

HintingDirective            ::= DEPRECATED StringFactor? EXPERIMENTAL |	PLATFORM | LIBRARY

Ident	            ::= NAME | KEYWORDESCAPE ReservedWord
ReservedWord	            ::=	NAME //===***
private IdentList	        ::=	IdentListItem IdentListRest*
private IdentListItem       ::= Ident {recoverUntil=recover_commaList}
private IdentListRest       ::= "," IdentListItem {pin=1}

ConstExpression	            ::=	LPAREN ConstExpression (COMMA ConstExpression)* RPAREN | Expression
	                        //|	LPAREN RecordConstExpression (SEMI RecordConstExpression)* RPAREN

primary                     ::= AT primary | AT AT primary | NOT primary | PLUS primary | MINUS primary | "^" Ident |
                                NUMBER_INT | NUMBER_REAL | NUMBER_HEX | NUMBER_BIN | TRUE | FALSE | NIL |
                                "(" Expression ")" | StringFactor | SetSection |
                                TypeID "(" Expression ")" | Designator

RelOp                       ::= "<" | ">" | "<=" | ">=" | "<>" | "=" | "in" | "is"
AddOp                       ::=	"+" | "-" | "or" | "xor"
MulOp                       ::= "*" | "/" | "div" | "mod" | "and" | "shl" | "shr" | "as"


Expression ::= ClosureExpression | expr_rel
expr_rel ::= expr_sum (RelOp expr_sum) *
expr_sum ::= expr_product (AddOp expr_product) *
expr_product ::= primary (MulOp primary) *

private expression_recover ::= !(NUMBER_INT | STRING)

/*expression ::= factor add_expression * {recoverUntil="expression_recover"}
private factor ::= primary mul_expression *
private primary ::= literal_expression | reference_expression qreference_expression *

left add_expression ::= '+' factor
left mul_expression ::= '*' primary

identifier ::= id
reference_expression ::= identifier {mixin="mypackage.MyReferenceExpressionImpl"}
left qreference_expression ::= '.' identifier {elementType="reference_expression"}

literal_expression ::= number | string*/

SetSection                  ::=	"[" [ Expression SetRest * ] "]" {pin=1}
private SetRest             ::= ( "," | ".." ) Expression {recoverUntil=recover_commaList}

ClosureExpression           ::= PROCEDURE [ FormalParameterSection ] Block | FUNCTION [ FormalParameterSection ] ":" TypeDecl Block
FormalParameterSection      ::= "(" [ FormalParameterList ] ")"
FormalParameterList         ::= FormalParameter (";" FormalParameter)*
FormalParameter             ::= [ CustomAttribute ] [ ParamType ] IdentList [ ":" TypeDecl ] [ "=" Expression ]
ParamType                    ::= CONST | VAR | OUT //ParmType


ExpressionsList	            ::= Expression (COMMA Expression)*

CustomAttribute	            ::=	LBRACK CustomAttributeDecl RBRACK
                            //| AssemblyAttribute
CustomAttributeDecl         ::= NamespacedQualifiedIdent LPAREN ExpressionsList RPAREN
StringFactor                ::= ControlString (QuotedString ControlString)* [QuotedString]
                              | QuotedString (ControlString QuotedString)* [ControlString]
QuotedString                ::=	STRING_LITERAL
ControlString               ::=	controlchar+
controlchar                 ::= CHARNUM NUMBER_INT | CHARNUM HEXNUM NUMBER_INT // ***===