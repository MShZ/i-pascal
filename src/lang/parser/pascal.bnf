{
  generateTokens=true
  generatePsi=true
  generateStubParser=true

  parserClass="com.siberika.idea.pascal.lang.parser.PascalParser"
  stubParserClass="com.siberika.idea.pascal.lang.parser.PascalParserUtil"

  implements="com.siberika.idea.pascal.lang.psi.PascalPsiElement"
  extends="com.siberika.idea.pascal.lang.psi.impl.PascalPsiElementImpl"

  psiClassPrefix="Pas"
  psiImplClassSuffix="Impl"
  psiPackage="com.siberika.idea.pascal.lang.psi"
  psiImplPackage="com.siberika.idea.pascal.lang.psi.impl"
  psiImplUtilClass="com.siberika.idea.pascal.lang.psi.impl.PascalPsiImplUtil"

  elementTypeHolderClass="com.siberika.idea.pascal.lang.psi.PasTypes"
  elementTypePrefix=""
  elementTypeClass="com.siberika.idea.pascal.lang.psi.PascalPsiElementType"
  tokenTypeClass="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  tokens = [
      COMMENT="COMMENT"
      STRING_LITERAL="STRING_LITERAL"

      AND="and"
      MOD="mod"
      OR="or"
      IDIV="div"
      SHR="shr"
      SHL="shl"
      IN="in"

      AS="as"


    IS="is"
    NIL="nil"

    CLASS="class"
    DISPINTERFACE="dispinterface"

    TRY="try"
    RAISE="raise"
    EXCEPT="except"
    ON="on"
    FINALLY="finally"

    PROGRAM="program"
    LIBRARY="library"
    PACKAGE="package"
    USES="uses"
    EXPORTS="exports"
    FINALIZATION="finalization"
    INITIALIZATION="initialization"

    THREADVAR="threadvar"
    ABSOLUTE="absolute"
    OUT="out"
    RESOURCESTRING="resourcestring"
    INLINE="inline"
    PACKED="packed"
    PROPERTY="property"
    ARRAY="array"
    SET="set"
    FILE="file"
    STRING="string"

    ASM="asm"
    GOTO="goto"
    LABEL="label"
    WITH="with"

    CONSTRUCTOR="constructor"
    DESTRUCTOR="destructor"
    INHERITED="inherited"
    OBJECT="object"
    OPERATOR="operator"
    REINTRODUCE="reintroduce"
    SELF="self"

    NOT="not"
    XOR="xor"

    TO="to"
    DOWNTO="downto"
    REPEAT="repeat"


      FALSE="false"
      TRUE="true"

      INTERFACE="interface"
      IMPLEMENTATION="implementation"

      VAR="var"
      CONST="const"
      TYPE="type"
      ARRAY="array"
      RECORD="record"
      PROCEDURE="procedure"
      FUNCTION="function"
      OF="of"

      CASE="case"
      BEGIN="begin"
      END="end"
      FOR="for"
      UNTIL="until"
      WHILE="while"
      DO="do"
      IF="if"
      THEN="then"
      ELSE="else"

      MULT="*"
      PLUS="+"
      MINUS="-"
      DIV="/"
      SEMI=";"
      COMMA=","
      LPAREN="("
      RPAREN=")"
      LBRACK="["
      RBRACK="]"
      EQ="="
      LT="<"
      GT=">"
      GE=">="
      LE="<="
      NE="<>"
      COLON=":"
      ASSIGN=":="
      DOT="."
      DEREF="^"
      AT="@"
      HEXNUM="$"
      CHARNUM="#"
      KEYWORDESCAPE="&"

  ]

  implements("pProgram")="com.siberika.idea.pascal.lang.psi.PascalNamedElement"
  extends("pProgram")="com.siberika.idea.pascal.lang.psi.impl.PascalNamedElementImpl"

}

external pascal             ::= parsePascal Module
private Module              ::= pUnit | pProgram //| pLibrary | pPackage

private pProgram            ::= progWithHead | progWoHead
private progWithHead        ::= ProgramHead UsesFileClause? Block "." {pin=1}
private progWoHead          ::= UsesFileClause? Block "."

pUnit                       ::= UnitHead UnitInterface UnitImplementation UnitBlock DOT {pin=1}
private UnitHead            ::= UNIT NamespaceName HintingDirective* SEMI {pin=1}
private UsesClause          ::= USES NamespaceNameList {pin=1}

UnitInterface               ::= INTERFACE [UsesClause] InterfaceDecl* {pin=1 name="interface section"}

private InterfaceDecl       ::= VarSection | ConstSection | TypeSection {recoverUntil=recover_decl}
                                // | ExportedProcHeading | ExportsSection | AssemblyAttribute
UnitImplementation          ::= IMPLEMENTATION [UsesClause] DeclSection* {pin=1 name="implementation section"}
private UnitBlock           ::= UnitInitialization END | CompoundStatement | END
UnitInitialization          ::= INITIALIZATION StatementList [UnitFinalization]  {pin=1 name="initialization section"}
UnitFinalization            ::= FINALIZATION StatementList  {pin=1 name="finalization section"}

private ProgramHead	        ::=	PROGRAM NamespaceName ProgramParamList? SEMI// {recoverUntil=moduleRecover pin=1}
ProgramParamList            ::= LPAREN progParam? progParamsRest* RPAREN {pin=1}
private progParamsRest      ::= "," progParam {pin=1}
private progParam           ::= Ident {recoverUntil=recover_commaList}

UsesFileClause	            ::=	USES NamespaceFileNameList {pin=1 name="uses clause"}
private NamespaceFileNameList ::= NamespaceFileName NamespaceFileNamesRest* SEMI
private NamespaceFileNamesRest ::= COMMA NamespaceFileName {pin=1}
private NamespaceFileName	::=	NamespaceName [IN QuotedString] {recoverUntil=recover_commaList}
private recover_commaList   ::= !(SEMI | RPAREN | COMMA | COLON | DOT | "]" | DO)

private NamespaceNameList   ::= NamespaceName NamespaceNamesRest* SEMI
private NamespaceNamesRest  ::= "," NamespaceName {pin=1}

Block	                    ::=	DeclSection* BlockBody? {pin=2}
private BlockBody	        ::=	CompoundStatement //|	AssemblerStatement

private DeclSection	        ::=	VarSection | TypeSection | ConstSection | ProcDecl | MethodDecl | LabelDeclSection// | ExportsSection | AssemblyAttribute
                            {recoverUntil=recover_decl}

private ProcKey             ::= FUNCTION | PROCEDURE
ProcDecl                    ::= ProcDeclHeading ";" FunctionDirective* [ProcBody] {name="procedure or function declaration"}
private ProcDeclHeading     ::= procDecl | funcDecl
private funcDecl            ::= [CustomAttribute] FUNCTION Ident [FormalParameterSection] ":" TypeDecl
private procDecl            ::= [CustomAttribute] PROCEDURE Ident [FormalParameterSection]
private FunctionDirective   ::= OverloadDirective | InlineDirective | CallConvention | OldCallConventionDirective | HintingDirective ";" | ExternalDirective // | "unsafe" ";"
private OverloadDirective   ::= OVERLOAD ";"
private OldCallConventionDirective ::= "far" ";" | "local" ";" | "near" ";"
private ExternalDirective   ::= "varargs" ";" | EXTERNAL ";" | EXTERNAL ConstExpression ExternalSpecifier* ";"
private ExternalSpecifier   ::= "name" ConstExpression | INDEX ConstExpression
private ProcBody            ::= FORWARD ";" FunctionDirective* | EXTERNAL ("name" Expression | INDEX Expression)* FunctionDirective* | Block ";"

MethodDecl                  ::= MethodDeclHeading ";" MethodDirective* [MethodBody] {name="method declaration"}
MethodBody          ::= Block ";"
MethodDeclHeading   ::= ProcMethod | FuncMethod
ProcMethod          ::= [CustomAttribute] MethodKey QualifiedIdent [GenericDefinition] [FormalParameterSection] {pin=2}
FuncMethod          ::= [CustomAttribute] [CLASS] FUNCTION QualifiedIdent [GenericDefinition] [FormalParameterSection] ":" [CustomAttribute] TypeDecl {pin=3}
MethodKey           ::= ([CLASS] PROCEDURE) | CONSTRUCTOR | DESTRUCTOR | (CLASS OPERATOR)
MethodDirective     ::= REINTRODUCE | OVERLOAD | BindingDirective | AbstractDirective | InlineDirective
                      | CallConvention | (HintingDirective ";") | DispIDDirective
private DispIDDirective     ::= DISPID Expression ";" {pin=1}
private CallConvention      ::= (CDECL | PASCAL | REGISTER | SAFECALL | STDCALL | EXPORT) ";"
private InlineDirective     ::= (INLINE | ASSEMBLER) ";"
private AbstractDirective   ::= (ABSTRACT | FINAL) ";"
private BindingDirective    ::= ((MESSAGE Expression) | STATIC | DYNAMIC | OVERRIDE | VIRTUAL) ";"

LabelDeclSection	        ::=	LABEL Label LabelsRest* SEMI {pin=1 name="label declaration"}
private LabelsRest          ::= "," Label {recoverUntil=recover_commaList}
private Label               ::= Ident | NUMBER_INT | NUMBER_HEX
VarSection	                ::=	VarKey VarDeclaration+ {pin=1 name="var section"}
VarKey	            ::=	VAR | THREADVAR
VarDeclaration	    ::=	[CustomAttribute] IdentList ":" TypeDecl [VarValueSpec] HintingDirective* SEMI {pin=3}
VarValueSpec	            ::=	ABSOLUTE Ident | ABSOLUTE ConstExpressionInt | EQ ConstExpression

ConstSection                ::= ConstKey ConstDeclaration+ {pin=1 name="const section"}
private ConstKey            ::= CONST |	RESOURCESTRING
private ConstDeclaration    ::= [CustomAttribute] Ident [":" TypeDecl] "=" ConstExpression HintingDirective* SEMI {pin=4}

TypeSection                 ::= TYPE TypeDeclaration TypeDeclaration* {pin=1 name="type section"}
TypeDeclaration             ::= [CustomAttribute] GenericTypeIdent "=" TypeDecl HintingDirective* ";" {pin=3 recoverUntil=recover_decl}
GenericTypeIdent    ::= Ident [GenericDefinition]
GenericDefinition   ::= SimpleGenericDefinition | ConstrainedGenericDefinition
SimpleGenericDefinition ::= "<" Ident IdentsRest* ">" {pin=1}
IdentsRest          ::= "," Ident {pin=1}
ConstrainedGenericDefinition ::= "<" ConstrainedGeneric ConstrainedGenericsRest ">" {pin=1}
ConstrainedGeneric  ::= Ident [ ":" GenericConstraint GenericConstraintsRest ]
GenericConstraint   ::= Ident | RECORD | CLASS | CONSTRUCTOR
GenericConstraintsRest ::= "," GenericConstraint {pin=1}
ConstrainedGenericsRest ::= ";" ConstrainedGeneric {pin=1}
GenericPostfix      ::=	"<" TypeDecl TypeDeclsRest* ">" {pin=1}
TypeDeclsRest       ::= "," TypeDecl {pin=1}

private recover_decl        ::= !('(' | ')' | ',' | '.' | ':' | ';' | '[' | ']' | '^' | ':=' | 'add' | 'at'
                                | ABSOLUTE | ASSEMBLER | AUTOMATED | BEGIN | CASE | CDECL | CLASS | COMMA | CONST | CONSTRUCTOR
                                | DEPRECATED | DESTRUCTOR | DO | DEFAULT | DISPID | DOWNTO | ELSE | END | EXCEPT | EXPERIMENTAL
                                | EXPORT | EXTERNAL | FINALIZATION | FINALLY | FUNCTION | INDEX | INHERITED | INITIALIZATION
                                | INLINE | INTERFACE | IMPLEMENTATION | KEYWORDESCAPE | LABEL | LBRACK | LIBRARY | MINUS | NAME
                                | IN | IMPLEMENTS | NOT | NUMBER_HEX | NUMBER_INT | OF | OVERLOAD | PASCAL | PLATFORM | PLUS | PROCEDURE | REGISTER
                                | RESOURCESTRING | RPAREN | SAFECALL | SEMI | STDCALL | THEN | THREADVAR | TO | TYPE | UNTIL | VAR
                                | PRIVATE | PROPERTY | PROTECTED | PUBLIC | PUBLISHED | RANGE | READ | STRICT | WRITE | USES
                                | (Ident "=") | RelOp | AddOp | MulOp)
                                | 'far' | 'local' | 'name' | 'near' | 'nodefault' | 'readonly' | 'remove' | 'stored' | 'varargs' | 'writeonly'

TypeDecl	                ::=	StrucType | PointerType | ProcedureType | StringType | VariantType | SimpleType | [TYPE] TypeID [GenericPostfix]

StrucType           ::= [PACKED] StrucTypePart
StrucTypePart       ::= ClassDecl | ArrayType | SetType | FileType

private ClassDecl           ::= ClassTypeTypeDecl | ClassTypeDecl | ClassHelperDecl | InterfaceTypeDecl | ObjectDecl | RecordDecl | RecordHelperDecl

private ClassTypeTypeDecl   ::= CLASS OF TypeID {pin(".*")="class of" name="metaclass declaration"}

ClassTypeDecl               ::= CLASS [ClassState] [ClassParent] ClassItem* END
                              | CLASS [ClassParent] {pin(".*")="CLASS" name="class declaration"}
private ClassState          ::= SEALED | ABSTRACT
private ClassItem           ::= Visibility | ClassMethod | ClassMethodResolution | ClassField | ClassProperty
                              | ConstSection | TypeSection | [CLASS] VarSection
private ClassMethodResolution ::= [CLASS] ProcKey TypeID "." Ident "=" Ident ";" {pin=2}
private ClassParent         ::= "(" TypeID ("," TypeID) ")" {pin=1}
private ClassField          ::= [CustomAttribute] IdentList ":" TypeDecl HintingDirective*


private ClassHelperDecl     ::= CLASS HELPER [ClassParent] FOR TypeID [ClassHelperItem] END {pin=1}
private ClassHelperItem     ::= Visibility | ClassMethod | ClassProperty | [CLASS] VarSection

InterfaceTypeDecl           ::= InterfaceKey [ClassParent] [InterfaceGuid] InterfaceItem* END
                             |	InterfaceKey [ClassParent] {pin(".*")=InterfaceKey}
private InterfaceItem       ::= ClassMethod | [CLASS] ClassProperty
private InterfaceGuid       ::= "[" QuotedString "]" {pin=1}
private InterfaceKey        ::= INTERFACE | DISPINTERFACE

ObjectDecl                  ::= OBJECT [ClassParent] ObjectItem* END {pin=1 name="object declaration"}
private ObjectItem          ::= Visibility | ClassMethod | ClassField

private Visibility ::= [STRICT] PROTECTED |[STRICT] PRIVATE | PUBLIC | PUBLISHED | AUTOMATED

RecordDecl                  ::= VariantRecord | SimpleRecord {name="record declaration"}
SimpleRecord        ::= RECORD RecordField* RecordItem* END {pin=1}
VariantRecord       ::= RECORD RecordField* RecordVariantSection END {pin=1}
RecordItem          ::= ClassMethod | ClassProperty | ConstSection | TypeSection | RecordField | [CLASS] VarSection
RecordField         ::= IdentList ":" TypeDecl HintingDirective* ";" {pin=2 recoverUntil=recover_decl}
RecordVariantSection ::= CASE [Ident ":"] TypeDecl OF (RecordVariant | ";" )+ {pin=1}
RecordVariant       ::= ConstExpression ("," ConstExpression)* ":" "(" RecordField* ")" {pin=3}

private RecordHelperDecl ::= RECORD HELPER FOR TypeID RecordHelperItem* END
private RecordHelperItem ::= ClassMethod | ClassProperty

private ClassMethod ::= MethodKey Ident [GenericDefinition] [FormalParameterSection] ";" MethodDirective*
                      | [CLASS] FUNCTION Ident [GenericDefinition] [FormalParameterSection] ":" [CustomAttribute] TypeDecl ";" MethodDirective*
private ClassProperty ::= [CustomAttribute] [CLASS] PROPERTY Ident [ClassPropertyArray] [":" TypeID] [ClassPropertyIndex] ClassPropertySpecifier* ";"
private ClassPropertyArray ::= "[" FormalParameterList "]" {pin=1}
private ClassPropertyIndex ::= INDEX Expression ";" {pin=1}
private ClassPropertySpecifier ::= ClassPropertyReadWrite | ClassPropertyDispInterface | "stored" Expression ";"
                                 | DEFAULT Expression ";" | DEFAULT ";" | "nodefault" ";" | IMPLEMENTS TypeID ";"
private ClassPropertyReadWrite ::= READ QualifiedIdent | WRITE QualifiedIdent | "add" QualifiedIdent | "remove" QualifiedIdent
private ClassPropertyDispInterface ::= "readonly" ";" | "writeonly" ";" | DispIDDirective

ArrayType           ::= ARRAY [ArrayIndexes] OF ArraySubType {pin=1}
ArrayIndexes ::= "[" [ArrayIndex] ArrayIndexRest* "]" {pin=1}
ArrayIndex          ::= TypeID | ConstExpressionInt RANGE ConstExpressionInt
ArrayIndexRest      ::= "," [ArrayIndex] {pin=1}
ArraySubType        ::= CONST | TypeDecl

SetType             ::= SET OF TypeDecl {pin=1}
FileType            ::= FILE [OF TypeDecl] {pin=1}
PointerType         ::= "^" TypeDecl | POINTER {pin=1}

private StringType          ::= STRING ["[" Expression "]"] | TypeID [CodePageNumber]
private CodePageNumber      ::= "(" ConstExpressionInt ")" {pin=1}
private VariantType         ::= Ident

ProcedureType       ::= MethodType | SimpleProcedureType | ProcedureReference
SimpleProcedureType ::= ProcedureTypeHeading
MethodType          ::= ProcedureTypeHeading OF OBJECT {pin=3}
ProcedureReference  ::= REFERENCE TO ProcedureTypeHeading {pin=1}
ProcedureTypeHeading ::= funcHeading | procHeading;
funcHeading         ::= FUNCTION [FormalParameterSection] ":" [CustomAttribute] TypeDecl {pin=1}
procHeading         ::= PROCEDURE [FormalParameterSection] {pin=1}

SimpleType          ::= Ident | EnumType | SubRangeType
SubRangeType        ::= ConstExpressionInt [RANGE ConstExpressionInt]
EnumType            ::= "(" EnumEl EnumRest* ")" {pin=1}
EnumRest            ::= "," EnumEl {pin=1}
EnumEl              ::= Ident ["=" Expression] {recoverUntil=recover_commaList}

TypeID              ::=	NamespacedQualifiedIdent

CompoundStatement           ::= BEGIN [StatementList] END {pin=1}
private StatementList       ::= [Statement] Statements*
private Statements          ::= SEMI [Statement]
private Statement           ::= [LabelId ":" ] StatementPart {recoverUntil=recover_statement}
private StatementPart       ::= RepeatStatement | WhileStatement | ForStatement
                              | CaseStatement | WithStatement | RaiseStatement// | AssemblerStatement
                              | CompoundStatement | IfStatement | TryStatement | SimpleStatement | stmtEmpty {recoverUntil=recover_statement}
SimpleStatement             ::= GotoStatement | stmtAssign | Designator
private stmtAssign          ::= stmtAssign1 | Designator ":=" NewStatement {pin(".*")=":="}
private stmtAssign1         ::= Designator ":=" Expression {pin=2}
NewStatement                ::= NEW "(" [ Expression ] ("," [ Expression ])* [ "," ConstExpression ] ")" //===***
private stmtEmpty           ::= //empty

private recover_statement   ::= !('(' | '.' | '[' | '^' | ';'
                                | BEGIN | BREAK | CASE | CONTINUE | EXIT | FOR | GOTO | IF | INHERITED | KEYWORDESCAPE | NAME | NUMBER_INT
                                | RAISE | REPEAT | TRY | WHILE | WITH | ELSE | END | EXCEPT | FINALIZATION | FINALLY | MINUS | NOT
                                | NUMBER_HEX | PLUS | SEMI | UNTIL | (Ident ":="))

Designator                  ::= //[ "inherited" ] , [ NamespacedQualifiedIdent | TypeID ] , { DesignatorItem } ===***
                                [INHERITED] ((TypeID DesignatorItem*) | DesignatorItem+)

DesignatorItem      ::= "^" | "." Ident | "[" ExpressionsList "]" | DesignatorItem2
DesignatorItem2     ::= "(" [ ExpressionColon ExpressionColons* ] ")"
private ExpressionColon     ::= Expression [ ColonConstruct ] {recoverUntil=recover_commaList}
private ExpressionColons    ::= "," ExpressionColon

ColonConstruct              ::= ":" Expression [ ":" Expression ]

RepeatStatement     ::= REPEAT [StatementList] UNTIL Expression {pin=1}
WhileStatement      ::= WHILE Expression DO Statement {pin=1}
ForStatement        ::= ForTo | ForDownto | ForEach
private ForTo               ::= FOR Designator ":=" Expression TO Expression DO Statement {pin=1}
private ForDownto           ::= FOR Designator ":=" Expression DOWNTO Expression DO Statement {pin=1}
private ForEach             ::= FOR Designator IN Expression DO Statement {pin=1}

IfStatement                 ::= IF Expression THEN Statement [ELSE Statement] {pin=1}

CaseStatement       ::= CASE Expression OF CaseItem* [ELSE StatementList [";"] ] END {pin=1}
CaseItem	        ::=	CaseLabel ("," CaseLabel)* ":" Statement [";"] {pin=3}
CaseLabel	        ::=	ExpressionInt [RANGE ExpressionInt] //{recoverUntil=recover_commaList}

TryStatement                ::= TryExcept | TryFinally
private TryFinally          ::= TRY StatementList FINALLY StatementList END {pin=1}
private TryExcept           ::= TRY StatementList EXCEPT HandlerList END {pin=1}
HandlerList                 ::= Handler+ [ELSE StatementList] | StatementList
Handler                     ::= ON Ident ":" TypeID "do" Statement ";"

WithStatement               ::= WITH Designator DesignatorsRest* DO Statement {pin=1}
private DesignatorsRest     ::= "," Designator {recoverUntil=recover_commaList}

RaiseStatement              ::= RAISE [Designator] ["at" Designator] {pin=1}

GotoStatement               ::= GOTO LabelId | EXIT [ "(" Expression ")" ] | BREAK | CONTINUE

LabelId                     ::= Ident | NUMBER_INT

SetSection                  ::=	"[" [ExpressionInt SetRest*] "]"// {pin=1}
SetRest             ::= ("," | RANGE | ) ExpressionInt //{recoverUntil=recover_commaList}

NamespacedQualifiedIdent ::= NamespaceName//(NamespaceName DOT)? QualifiedIdent
QualifiedIdent	    ::=	IdentsBegin* Ident
private IdentsBegin         ::= Ident "." {pin=2}
NamespaceName	            ::=	NamespaceItem DotIdent*
DotIdent            ::= "." NamespaceItem {pin=1}
NamespaceItem       ::= Ident {recoverUntil=recover_decl}

HintingDirective            ::= (DEPRECATED [StringFactor]) | EXPERIMENTAL | PLATFORM | LIBRARY

private Ident_kw            ::= OUT | EXIT | BREAK | CONTINUE | OPERATOR | SELF | NEW | REINTRODUCE | OVERLOAD | MESSAGE |STATIC | DYNAMIC
                              | OVERRIDE | VIRTUAL | ABSTRACT | SEALED | FINAL | ASSEMBLER | CDECL | PASCAL | REGISTER | SAFECALL | STDCALL
                              | EXPORT | STRICT | PRIVATE | PROTECTED | PUBLIC | PUBLISHED | AUTOMATED | DISPID | EXTERNAL | FORWARD | HELPER
                              | DEFAULT | IMPLEMENTS | INDEX | READ | WRITE | DEPRECATED | EXPERIMENTAL | PLATFORM | REFERENCE
Ident	            ::= KEYWORDESCAPE ReservedWord | Ident_kw | NAME
ReservedWord	            ::=	NAME //===***
IdentList	        ::=	IdentListItem IdentListRest*
IdentListRest       ::= "," IdentListItem {pin=1}
IdentListItem       ::= Ident {recoverUntil=recover_decl}
private recover_identList ::= !(')' | ',' | ':' | ';' | '=' | ']')

ConstExpressionInt          ::=	ExpressionInt {name="integer constant expression"}
ConstExpression	            ::=	Expression | NewConstExpression | RecordConstExpression {name="constant expression"}
NewConstExpression	        ::=	LPAREN ConstExpression (COMMA ConstExpression)* RPAREN | Expression
RecordConstExpression       ::= Expression | RecordConstValue;
RecordConstValue            ::= "(" RecordValue RecordValueRest* ")" {pin=1}
private RecordValueRest     ::= ";" RecordValue
private RecordValue         ::= Ident ":" RecordConstExpression

primary                     ::= AT primary | AT AT primary | NOT primary | PLUS primary | MINUS primary | "^" Ident |
                                NUMBER_INT | NUMBER_REAL | NUMBER_HEX | NUMBER_BIN | TRUE | FALSE | NIL |
                                "(" Expression ")" | StringFactor | SetSection |
                                TypeID "(" Expression ")" | Designator

primaryInt                  ::= NOT primaryInt | PLUS primaryInt | MINUS primaryInt | NUMBER_INT | NUMBER_HEX
                                "(" ExpressionInt ")" | TypeID "(" Expression ")" | Designator


RelOp                       ::= "<" | ">" | "<=" | ">=" | "<>" | "=" | IN | IS
AddOp                       ::=	"+" | "-" | OR | XOR
MulOp                       ::= "*" | "/" | IDIV | MOD | AND | SHL | SHR | AS


Expression ::= ClosureExpression | expr_rel
expr_rel ::= expr_sum (RelOp expr_sum)*
expr_sum ::= expr_product (AddOp expr_product)*
expr_product ::= primary (MulOp primary)*

ExpressionInt ::= expr_relInt
private expr_relInt ::= expr_sumInt (RelOp expr_sumInt)*
private expr_sumInt ::= expr_productInt (AddOp expr_productInt)*
private expr_productInt ::= primaryInt (MulOp primaryInt)*

private expression_recover ::= !(NUMBER_INT | STRING)

/*expression ::= factor add_expression * {recoverUntil="expression_recover"}
private factor ::= primary mul_expression *
private primary ::= literal_expression | reference_expression qreference_expression *

left add_expression ::= '+' factor
left mul_expression ::= '*' primary

identifier ::= id
reference_expression ::= identifier {mixin="mypackage.MyReferenceExpressionImpl"}
left qreference_expression ::= '.' identifier {elementType="reference_expression"}

literal_expression ::= number | string*/

ClosureExpression           ::= PROCEDURE [ FormalParameterSection ] Block | FUNCTION [ FormalParameterSection ] ":" TypeDecl Block
FormalParameterSection      ::= "(" [ FormalParameterList ] ")"
FormalParameterList         ::= FormalParameter (";" FormalParameter)*
FormalParameter             ::= [ CustomAttribute ] [ ParamType ] IdentList [ ":" TypeDecl ] [ "=" Expression ]
ParamType                    ::= CONST | VAR | OUT //ParmType


ExpressionsList	            ::= Expression (COMMA Expression)*

CustomAttribute	            ::=	LBRACK CustomAttributeDecl RBRACK
                            //| AssemblyAttribute
CustomAttributeDecl         ::= NamespacedQualifiedIdent LPAREN ExpressionsList RPAREN
StringFactor                ::= ControlString (QuotedString ControlString)* [QuotedString]
                              | QuotedString (ControlString QuotedString)* [ControlString]
QuotedString                ::=	STRING_LITERAL
ControlString               ::=	controlchar+
controlchar                 ::= CHARNUM NUMBER_INT | CHARNUM HEXNUM NUMBER_INT // ***===