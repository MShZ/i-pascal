{
  generateTokens=true
  generatePsi=true
  generateStubParser=true

  parserClass="com.siberika.idea.pascal.lang.parser.PascalParser"
  stubParserClass="com.siberika.idea.pascal.lang.parser.PascalParserUtil"

  implements="com.siberika.idea.pascal.lang.psi.PascalPsiElement"
  extends="com.siberika.idea.pascal.lang.psi.impl.PascalPsiElementImpl"

  psiClassPrefix="Pas"
  psiImplClassSuffix="Impl"
  psiPackage="com.siberika.idea.pascal.lang.psi"
  psiImplPackage="com.siberika.idea.pascal.lang.psi.impl"
  //psiImplUtilClass="com.siberika.idea.pascal.lang.psi.impl.PascalPsiImplUtil"

  elementTypeHolderClass="com.siberika.idea.pascal.lang.psi.PasTypes"
  elementTypePrefix=""
  elementTypeClass="com.siberika.idea.pascal.lang.psi.PascalPsiElementType"
  tokenTypeClass="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  //implements("rule|attr")="org.intellij.grammar.psi.BnfNamedElement"
  //extends("Module")="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  tokens = [
      COMMENT="comment"
      QSTRING="qstring"

      AND="and"
      MOD="mod"
      OR="or"
      IDIV="div"
      SHR="shr"
      SHL="shl"
      IN="in"

      AS="as"


    IS="is"
    NIL="nil"

    CLASS="class"
    DISPINTERFACE="dispinterface"

    TRY="try"
    RAISE="raise"
    EXCEPT="except"
    ON="on"
    FINALLY="finally"

    PROGRAM="program"
    LIBRARY="library"
    PACKAGE="package"
    USES="uses"
    EXPORTS="exports"
    FINALIZATION="finalization"
    INITIALIZATION="initialization"

    THREADVAR="threadvar"
    ABSOLUTE="absolute"
    OUT="out"
    RESOURCESTRING="resourcestring"
    INLINE="inline"
    PACKED="packed"
    PROPERTY="property"
    ARRAY="array"
    SET="set"
    FILE="file"
    STRING="string"

    ASM="asm"
    GOTO="goto"
    LABEL="label"
    WITH="with"

    CONSTRUCTOR="constructor"
    DESTRUCTOR="destructor"
    INHERITED="inherited"
    OBJECT="object"
    OPERATOR="operator"
    REINTRODUCE="reintroduce"
    SELF="self"

    NOT="not"
    XOR="xor"

    TO="to"
    DOWNTO="downto"
    REPEAT="repeat"


      FALSE="false"
      TRUE="true"
      NUMBER="number"

      INTERFACE="interface"
      IMPLEMENTATION="implementation"

      VAR="var"
      CONST="const"
      TYPE="type"
      ARRAY="array"
      RECORD="record"
      PROCEDURE="procedure"
      FUNCTION="function"
      OF="of"

      CASE="case"
      BEGIN="begin"
      END="end"
      FOR="for"
      UNTIL="until"
      WHILE="while"
      DO="do"
      IF="if"
      THEN="then"
      ELSE="else"

      MULT="*"
      PLUS="+"
      MINUS="-"
      DIV="/"
      SEMI=";"
      COMMA=","
      LPAREN="("
      RPAREN=")"
      LBRACK="["
      RBRACK="]"
      EQ="="
      LT="<"
      GT=">"
      GE=">="
      LE="<="
      NE="<>"
      COLON=":"
      ASSIGN=":="
      DOT="."
      DEREF="^"
      ADDR="@"
      HEXNUM="$"
      CHARNUM="#"
      KEYWORDESCAPE="&"

  ]

}

external pascal             ::= parsePascal Module
Module                      ::= pProgram | pUnit | pLibrary | pPackage
pPackage                    ::= PACKAGE END // ***===
pLibrary                    ::= LIBRARY END // ***===
pUnit                       ::= UNIT END    // ***===

pProgram                    ::= ProgramHead? UsesFileClause? Block SEMI
private ProgramHead	            ::=	PROGRAM NamespaceName ProgramParmSeq? SEMI
private ProgramParmSeq	        ::=	LPAREN Ident? (COMMA Ident)* RPAREN

UsesFileClause	            ::=	USES NamespaceFileNameList
private NamespaceFileNameList	    ::=	NamespaceFileName (COMMA NamespaceFileName)* SEMI
NamespaceFileName	        ::=	NamespaceName [IN QuotedString]

Block	                    ::=	DeclSection* BlockBody?
BlockBody	                ::=	CompoundStatement //|	AssemblerStatement

//DeclSection	            ::=	LabelDeclSection | ConstSection | TypeSection | VarSection | MethodDecl | ProcDecl | ExportsSection | AssemblyAttribute
//LabelDeclSection	        ::=	LABEL Label (COMMA Label)* SEMI
DeclSection	                ::=	VarSection {recoverUntil=commonRecover}
commonRecover               ::= !(BEGIN | END | ';')
VarSection	                ::=	VarKey VarDeclaration+
VarKey	                    ::=	VAR | THREADVAR
VarDeclaration	            ::=	CustomAttribute? IdentList COLON TypeDecl VarValueSpec? HintingDirective* SEMI
VarValueSpec	            ::=	ABSOLUTE Ident | ABSOLUTE ConstExpression | EQ ConstExpression

//TypeDecl	                ::=	StrucType | PointerType | StringType | ProcedureType | VariantType | SimpleType | TYPE? TypeID GenericPostfix?
TypeDecl	                ::=	TYPE? TypeID //GenericPostfix?
TypeID                      ::=	NamespacedQualifiedIdent

CompoundStatement           ::= BEGIN StatementList? END {pin=3}
StatementList               ::= Statement? (SEMI Statement?)* {recoverUntil=statement_recover}
private statement_recover   ::= commonRecover
Statement                   ::= NAME //===***

NamespacedQualifiedIdent    ::= (NamespaceName DOT)? QualifiedIdent
NamespaceName	            ::=	Ident (DOT Ident)*
QualifiedIdent	            ::=	(Ident DOT)* Ident

HintingDirective            ::= DEPRECATED StringFactor? EXPERIMENTAL |	PLATFORM | LIBRARY

Ident	                    ::= NAME | KEYWORDESCAPE ReservedWord
IdentList	                ::=	Ident (COMMA Ident)*
ReservedWord	            ::=	NAME

ConstExpression	            ::=	Expression | LPAREN ConstExpression (COMMA ConstExpression)* RPAREN
	                        //|	LPAREN RecordConstExpression (SEMI RecordConstExpression)* RPAREN
Expression                  ::= NUMBER
ExpressionList	            ::= Expression (COMMA Expression)*

CustomAttribute	            ::=	LBRACK CustomAttributeDecl RBRACK
                            //| AssemblyAttribute
CustomAttributeDecl         ::= NamespacedQualifiedIdent LPAREN ExpressionList RPAREN

StringFactor                ::= ControlString (QuotedString ControlString)* QuotedString?
                            | QuotedString (ControlString QuotedString) ControlString?
QuotedString                ::=	STRING*
ControlString               ::=	controlchar+
controlchar                 ::= CHARNUM NUMBER | CHARNUM HEXNUM NUMBER // ***===